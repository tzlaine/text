// Copyright (C) 2020 T. Zachary Laine
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// Warning! This file is autogenerated.
#include <boost/text/normalize_string.hpp>
#include <boost/text/transcode_view.hpp>
#include <boost/text/string_utility.hpp>

#include <gtest/gtest.h>

#include <algorithm>



TEST(normalization, nfc_056_000)
{
    // CE50;CE50;110E 1174 11BB;CE50;110E 1174 11BB; 
    // (칐; 칐; 칐; 칐; 칐; ) HANGUL SYLLABLE CYISS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE50 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE50 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1174, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCE50 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1174, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_001)
{
    // CE51;CE51;110E 1174 11BC;CE51;110E 1174 11BC; 
    // (칑; 칑; 칑; 칑; 칑; ) HANGUL SYLLABLE CYING
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE51 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE51 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1174, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCE51 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1174, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_002)
{
    // CE52;CE52;110E 1174 11BD;CE52;110E 1174 11BD; 
    // (칒; 칒; 칒; 칒; 칒; ) HANGUL SYLLABLE CYIJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE52 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE52 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1174, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCE52 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1174, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_003)
{
    // CE53;CE53;110E 1174 11BE;CE53;110E 1174 11BE; 
    // (칓; 칓; 칓; 칓; 칓; ) HANGUL SYLLABLE CYIC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE53 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE53 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1174, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCE53 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1174, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_004)
{
    // CE54;CE54;110E 1174 11BF;CE54;110E 1174 11BF; 
    // (칔; 칔; 칔; 칔; 칔; ) HANGUL SYLLABLE CYIK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE54 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE54 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1174, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCE54 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1174, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_005)
{
    // CE55;CE55;110E 1174 11C0;CE55;110E 1174 11C0; 
    // (칕; 칕; 칕; 칕; 칕; ) HANGUL SYLLABLE CYIT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE55 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE55 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1174, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE55 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1174, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_006)
{
    // CE56;CE56;110E 1174 11C1;CE56;110E 1174 11C1; 
    // (칖; 칖; 칖; 칖; 칖; ) HANGUL SYLLABLE CYIP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE56 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE56 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1174, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE56 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1174, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_007)
{
    // CE57;CE57;110E 1174 11C2;CE57;110E 1174 11C2; 
    // (칗; 칗; 칗; 칗; 칗; ) HANGUL SYLLABLE CYIH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE57 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE57 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1174, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE57 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1174, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_008)
{
    // CE58;CE58;110E 1175;CE58;110E 1175; 
    // (치; 치; 치; 치; 치; ) HANGUL SYLLABLE CI
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE58 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE58 }};
        std::array<char32_t, 2> const c3 = {{ 0x110E, 0x1175 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE58 }};
        std::array<char32_t, 2> const c5 = {{ 0x110E, 0x1175 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_009)
{
    // CE59;CE59;110E 1175 11A8;CE59;110E 1175 11A8; 
    // (칙; 칙; 칙; 칙; 칙; ) HANGUL SYLLABLE CIG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE59 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE59 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE59 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_010)
{
    // CE5A;CE5A;110E 1175 11A9;CE5A;110E 1175 11A9; 
    // (칚; 칚; 칚; 칚; 칚; ) HANGUL SYLLABLE CIGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE5A }};
        std::array<char32_t, 1> const c2 = {{ 0xCE5A }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE5A }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_011)
{
    // CE5B;CE5B;110E 1175 11AA;CE5B;110E 1175 11AA; 
    // (칛; 칛; 칛; 칛; 칛; ) HANGUL SYLLABLE CIGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE5B }};
        std::array<char32_t, 1> const c2 = {{ 0xCE5B }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCE5B }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_012)
{
    // CE5C;CE5C;110E 1175 11AB;CE5C;110E 1175 11AB; 
    // (친; 친; 친; 친; 친; ) HANGUL SYLLABLE CIN
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE5C }};
        std::array<char32_t, 1> const c2 = {{ 0xCE5C }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCE5C }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_013)
{
    // CE5D;CE5D;110E 1175 11AC;CE5D;110E 1175 11AC; 
    // (칝; 칝; 칝; 칝; 칝; ) HANGUL SYLLABLE CINJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE5D }};
        std::array<char32_t, 1> const c2 = {{ 0xCE5D }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCE5D }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_014)
{
    // CE5E;CE5E;110E 1175 11AD;CE5E;110E 1175 11AD; 
    // (칞; 칞; 칞; 칞; 칞; ) HANGUL SYLLABLE CINH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE5E }};
        std::array<char32_t, 1> const c2 = {{ 0xCE5E }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCE5E }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_015)
{
    // CE5F;CE5F;110E 1175 11AE;CE5F;110E 1175 11AE; 
    // (칟; 칟; 칟; 칟; 칟; ) HANGUL SYLLABLE CID
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE5F }};
        std::array<char32_t, 1> const c2 = {{ 0xCE5F }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCE5F }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_016)
{
    // CE60;CE60;110E 1175 11AF;CE60;110E 1175 11AF; 
    // (칠; 칠; 칠; 칠; 칠; ) HANGUL SYLLABLE CIL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE60 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE60 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCE60 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_017)
{
    // CE61;CE61;110E 1175 11B0;CE61;110E 1175 11B0; 
    // (칡; 칡; 칡; 칡; 칡; ) HANGUL SYLLABLE CILG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE61 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE61 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE61 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_018)
{
    // CE62;CE62;110E 1175 11B1;CE62;110E 1175 11B1; 
    // (칢; 칢; 칢; 칢; 칢; ) HANGUL SYLLABLE CILM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE62 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE62 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE62 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_019)
{
    // CE63;CE63;110E 1175 11B2;CE63;110E 1175 11B2; 
    // (칣; 칣; 칣; 칣; 칣; ) HANGUL SYLLABLE CILB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE63 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE63 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE63 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_020)
{
    // CE64;CE64;110E 1175 11B3;CE64;110E 1175 11B3; 
    // (칤; 칤; 칤; 칤; 칤; ) HANGUL SYLLABLE CILS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE64 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE64 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE64 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_021)
{
    // CE65;CE65;110E 1175 11B4;CE65;110E 1175 11B4; 
    // (칥; 칥; 칥; 칥; 칥; ) HANGUL SYLLABLE CILT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE65 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE65 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE65 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_022)
{
    // CE66;CE66;110E 1175 11B5;CE66;110E 1175 11B5; 
    // (칦; 칦; 칦; 칦; 칦; ) HANGUL SYLLABLE CILP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE66 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE66 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE66 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_023)
{
    // CE67;CE67;110E 1175 11B6;CE67;110E 1175 11B6; 
    // (칧; 칧; 칧; 칧; 칧; ) HANGUL SYLLABLE CILH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE67 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE67 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE67 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_024)
{
    // CE68;CE68;110E 1175 11B7;CE68;110E 1175 11B7; 
    // (침; 침; 침; 침; 침; ) HANGUL SYLLABLE CIM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE68 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE68 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE68 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_025)
{
    // CE69;CE69;110E 1175 11B8;CE69;110E 1175 11B8; 
    // (칩; 칩; 칩; 칩; 칩; ) HANGUL SYLLABLE CIB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE69 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE69 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE69 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_026)
{
    // CE6A;CE6A;110E 1175 11B9;CE6A;110E 1175 11B9; 
    // (칪; 칪; 칪; 칪; 칪; ) HANGUL SYLLABLE CIBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE6A }};
        std::array<char32_t, 1> const c2 = {{ 0xCE6A }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE6A }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_027)
{
    // CE6B;CE6B;110E 1175 11BA;CE6B;110E 1175 11BA; 
    // (칫; 칫; 칫; 칫; 칫; ) HANGUL SYLLABLE CIS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE6B }};
        std::array<char32_t, 1> const c2 = {{ 0xCE6B }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCE6B }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_028)
{
    // CE6C;CE6C;110E 1175 11BB;CE6C;110E 1175 11BB; 
    // (칬; 칬; 칬; 칬; 칬; ) HANGUL SYLLABLE CISS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE6C }};
        std::array<char32_t, 1> const c2 = {{ 0xCE6C }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCE6C }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_029)
{
    // CE6D;CE6D;110E 1175 11BC;CE6D;110E 1175 11BC; 
    // (칭; 칭; 칭; 칭; 칭; ) HANGUL SYLLABLE CING
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE6D }};
        std::array<char32_t, 1> const c2 = {{ 0xCE6D }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCE6D }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_030)
{
    // CE6E;CE6E;110E 1175 11BD;CE6E;110E 1175 11BD; 
    // (칮; 칮; 칮; 칮; 칮; ) HANGUL SYLLABLE CIJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE6E }};
        std::array<char32_t, 1> const c2 = {{ 0xCE6E }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCE6E }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_031)
{
    // CE6F;CE6F;110E 1175 11BE;CE6F;110E 1175 11BE; 
    // (칯; 칯; 칯; 칯; 칯; ) HANGUL SYLLABLE CIC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE6F }};
        std::array<char32_t, 1> const c2 = {{ 0xCE6F }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCE6F }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_032)
{
    // CE70;CE70;110E 1175 11BF;CE70;110E 1175 11BF; 
    // (칰; 칰; 칰; 칰; 칰; ) HANGUL SYLLABLE CIK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE70 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE70 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCE70 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_033)
{
    // CE71;CE71;110E 1175 11C0;CE71;110E 1175 11C0; 
    // (칱; 칱; 칱; 칱; 칱; ) HANGUL SYLLABLE CIT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE71 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE71 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE71 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_034)
{
    // CE72;CE72;110E 1175 11C1;CE72;110E 1175 11C1; 
    // (칲; 칲; 칲; 칲; 칲; ) HANGUL SYLLABLE CIP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE72 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE72 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE72 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_035)
{
    // CE73;CE73;110E 1175 11C2;CE73;110E 1175 11C2; 
    // (칳; 칳; 칳; 칳; 칳; ) HANGUL SYLLABLE CIH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE73 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE73 }};
        std::array<char32_t, 3> const c3 = {{ 0x110E, 0x1175, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE73 }};
        std::array<char32_t, 3> const c5 = {{ 0x110E, 0x1175, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_036)
{
    // CE74;CE74;110F 1161;CE74;110F 1161; 
    // (카; 카; 카; 카; 카; ) HANGUL SYLLABLE KA
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE74 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE74 }};
        std::array<char32_t, 2> const c3 = {{ 0x110F, 0x1161 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE74 }};
        std::array<char32_t, 2> const c5 = {{ 0x110F, 0x1161 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_037)
{
    // CE75;CE75;110F 1161 11A8;CE75;110F 1161 11A8; 
    // (칵; 칵; 칵; 칵; 칵; ) HANGUL SYLLABLE KAG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE75 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE75 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE75 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_038)
{
    // CE76;CE76;110F 1161 11A9;CE76;110F 1161 11A9; 
    // (칶; 칶; 칶; 칶; 칶; ) HANGUL SYLLABLE KAGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE76 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE76 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE76 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_039)
{
    // CE77;CE77;110F 1161 11AA;CE77;110F 1161 11AA; 
    // (칷; 칷; 칷; 칷; 칷; ) HANGUL SYLLABLE KAGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE77 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE77 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCE77 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_040)
{
    // CE78;CE78;110F 1161 11AB;CE78;110F 1161 11AB; 
    // (칸; 칸; 칸; 칸; 칸; ) HANGUL SYLLABLE KAN
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE78 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE78 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCE78 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_041)
{
    // CE79;CE79;110F 1161 11AC;CE79;110F 1161 11AC; 
    // (칹; 칹; 칹; 칹; 칹; ) HANGUL SYLLABLE KANJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE79 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE79 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCE79 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_042)
{
    // CE7A;CE7A;110F 1161 11AD;CE7A;110F 1161 11AD; 
    // (칺; 칺; 칺; 칺; 칺; ) HANGUL SYLLABLE KANH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE7A }};
        std::array<char32_t, 1> const c2 = {{ 0xCE7A }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCE7A }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_043)
{
    // CE7B;CE7B;110F 1161 11AE;CE7B;110F 1161 11AE; 
    // (칻; 칻; 칻; 칻; 칻; ) HANGUL SYLLABLE KAD
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE7B }};
        std::array<char32_t, 1> const c2 = {{ 0xCE7B }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCE7B }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_044)
{
    // CE7C;CE7C;110F 1161 11AF;CE7C;110F 1161 11AF; 
    // (칼; 칼; 칼; 칼; 칼; ) HANGUL SYLLABLE KAL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE7C }};
        std::array<char32_t, 1> const c2 = {{ 0xCE7C }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCE7C }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_045)
{
    // CE7D;CE7D;110F 1161 11B0;CE7D;110F 1161 11B0; 
    // (칽; 칽; 칽; 칽; 칽; ) HANGUL SYLLABLE KALG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE7D }};
        std::array<char32_t, 1> const c2 = {{ 0xCE7D }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE7D }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_046)
{
    // CE7E;CE7E;110F 1161 11B1;CE7E;110F 1161 11B1; 
    // (칾; 칾; 칾; 칾; 칾; ) HANGUL SYLLABLE KALM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE7E }};
        std::array<char32_t, 1> const c2 = {{ 0xCE7E }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE7E }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_047)
{
    // CE7F;CE7F;110F 1161 11B2;CE7F;110F 1161 11B2; 
    // (칿; 칿; 칿; 칿; 칿; ) HANGUL SYLLABLE KALB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE7F }};
        std::array<char32_t, 1> const c2 = {{ 0xCE7F }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE7F }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_048)
{
    // CE80;CE80;110F 1161 11B3;CE80;110F 1161 11B3; 
    // (캀; 캀; 캀; 캀; 캀; ) HANGUL SYLLABLE KALS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE80 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE80 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE80 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_049)
{
    // CE81;CE81;110F 1161 11B4;CE81;110F 1161 11B4; 
    // (캁; 캁; 캁; 캁; 캁; ) HANGUL SYLLABLE KALT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE81 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE81 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE81 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_050)
{
    // CE82;CE82;110F 1161 11B5;CE82;110F 1161 11B5; 
    // (캂; 캂; 캂; 캂; 캂; ) HANGUL SYLLABLE KALP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE82 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE82 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE82 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_051)
{
    // CE83;CE83;110F 1161 11B6;CE83;110F 1161 11B6; 
    // (캃; 캃; 캃; 캃; 캃; ) HANGUL SYLLABLE KALH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE83 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE83 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE83 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_052)
{
    // CE84;CE84;110F 1161 11B7;CE84;110F 1161 11B7; 
    // (캄; 캄; 캄; 캄; 캄; ) HANGUL SYLLABLE KAM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE84 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE84 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE84 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_053)
{
    // CE85;CE85;110F 1161 11B8;CE85;110F 1161 11B8; 
    // (캅; 캅; 캅; 캅; 캅; ) HANGUL SYLLABLE KAB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE85 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE85 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE85 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_054)
{
    // CE86;CE86;110F 1161 11B9;CE86;110F 1161 11B9; 
    // (캆; 캆; 캆; 캆; 캆; ) HANGUL SYLLABLE KABS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE86 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE86 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE86 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_055)
{
    // CE87;CE87;110F 1161 11BA;CE87;110F 1161 11BA; 
    // (캇; 캇; 캇; 캇; 캇; ) HANGUL SYLLABLE KAS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE87 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE87 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCE87 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_056)
{
    // CE88;CE88;110F 1161 11BB;CE88;110F 1161 11BB; 
    // (캈; 캈; 캈; 캈; 캈; ) HANGUL SYLLABLE KASS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE88 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE88 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCE88 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_057)
{
    // CE89;CE89;110F 1161 11BC;CE89;110F 1161 11BC; 
    // (캉; 캉; 캉; 캉; 캉; ) HANGUL SYLLABLE KANG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE89 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE89 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCE89 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_058)
{
    // CE8A;CE8A;110F 1161 11BD;CE8A;110F 1161 11BD; 
    // (캊; 캊; 캊; 캊; 캊; ) HANGUL SYLLABLE KAJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE8A }};
        std::array<char32_t, 1> const c2 = {{ 0xCE8A }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCE8A }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_059)
{
    // CE8B;CE8B;110F 1161 11BE;CE8B;110F 1161 11BE; 
    // (캋; 캋; 캋; 캋; 캋; ) HANGUL SYLLABLE KAC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE8B }};
        std::array<char32_t, 1> const c2 = {{ 0xCE8B }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCE8B }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_060)
{
    // CE8C;CE8C;110F 1161 11BF;CE8C;110F 1161 11BF; 
    // (캌; 캌; 캌; 캌; 캌; ) HANGUL SYLLABLE KAK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE8C }};
        std::array<char32_t, 1> const c2 = {{ 0xCE8C }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCE8C }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_061)
{
    // CE8D;CE8D;110F 1161 11C0;CE8D;110F 1161 11C0; 
    // (캍; 캍; 캍; 캍; 캍; ) HANGUL SYLLABLE KAT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE8D }};
        std::array<char32_t, 1> const c2 = {{ 0xCE8D }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE8D }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_062)
{
    // CE8E;CE8E;110F 1161 11C1;CE8E;110F 1161 11C1; 
    // (캎; 캎; 캎; 캎; 캎; ) HANGUL SYLLABLE KAP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE8E }};
        std::array<char32_t, 1> const c2 = {{ 0xCE8E }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE8E }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_063)
{
    // CE8F;CE8F;110F 1161 11C2;CE8F;110F 1161 11C2; 
    // (캏; 캏; 캏; 캏; 캏; ) HANGUL SYLLABLE KAH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE8F }};
        std::array<char32_t, 1> const c2 = {{ 0xCE8F }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1161, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE8F }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1161, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_064)
{
    // CE90;CE90;110F 1162;CE90;110F 1162; 
    // (캐; 캐; 캐; 캐; 캐; ) HANGUL SYLLABLE KAE
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE90 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE90 }};
        std::array<char32_t, 2> const c3 = {{ 0x110F, 0x1162 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE90 }};
        std::array<char32_t, 2> const c5 = {{ 0x110F, 0x1162 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_065)
{
    // CE91;CE91;110F 1162 11A8;CE91;110F 1162 11A8; 
    // (캑; 캑; 캑; 캑; 캑; ) HANGUL SYLLABLE KAEG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE91 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE91 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE91 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_066)
{
    // CE92;CE92;110F 1162 11A9;CE92;110F 1162 11A9; 
    // (캒; 캒; 캒; 캒; 캒; ) HANGUL SYLLABLE KAEGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE92 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE92 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE92 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_067)
{
    // CE93;CE93;110F 1162 11AA;CE93;110F 1162 11AA; 
    // (캓; 캓; 캓; 캓; 캓; ) HANGUL SYLLABLE KAEGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE93 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE93 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCE93 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_068)
{
    // CE94;CE94;110F 1162 11AB;CE94;110F 1162 11AB; 
    // (캔; 캔; 캔; 캔; 캔; ) HANGUL SYLLABLE KAEN
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE94 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE94 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCE94 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_069)
{
    // CE95;CE95;110F 1162 11AC;CE95;110F 1162 11AC; 
    // (캕; 캕; 캕; 캕; 캕; ) HANGUL SYLLABLE KAENJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE95 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE95 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCE95 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_070)
{
    // CE96;CE96;110F 1162 11AD;CE96;110F 1162 11AD; 
    // (캖; 캖; 캖; 캖; 캖; ) HANGUL SYLLABLE KAENH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE96 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE96 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCE96 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_071)
{
    // CE97;CE97;110F 1162 11AE;CE97;110F 1162 11AE; 
    // (캗; 캗; 캗; 캗; 캗; ) HANGUL SYLLABLE KAED
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE97 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE97 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCE97 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_072)
{
    // CE98;CE98;110F 1162 11AF;CE98;110F 1162 11AF; 
    // (캘; 캘; 캘; 캘; 캘; ) HANGUL SYLLABLE KAEL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE98 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE98 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCE98 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_073)
{
    // CE99;CE99;110F 1162 11B0;CE99;110F 1162 11B0; 
    // (캙; 캙; 캙; 캙; 캙; ) HANGUL SYLLABLE KAELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE99 }};
        std::array<char32_t, 1> const c2 = {{ 0xCE99 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE99 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_074)
{
    // CE9A;CE9A;110F 1162 11B1;CE9A;110F 1162 11B1; 
    // (캚; 캚; 캚; 캚; 캚; ) HANGUL SYLLABLE KAELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE9A }};
        std::array<char32_t, 1> const c2 = {{ 0xCE9A }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE9A }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_075)
{
    // CE9B;CE9B;110F 1162 11B2;CE9B;110F 1162 11B2; 
    // (캛; 캛; 캛; 캛; 캛; ) HANGUL SYLLABLE KAELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE9B }};
        std::array<char32_t, 1> const c2 = {{ 0xCE9B }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE9B }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_076)
{
    // CE9C;CE9C;110F 1162 11B3;CE9C;110F 1162 11B3; 
    // (캜; 캜; 캜; 캜; 캜; ) HANGUL SYLLABLE KAELS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE9C }};
        std::array<char32_t, 1> const c2 = {{ 0xCE9C }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE9C }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_077)
{
    // CE9D;CE9D;110F 1162 11B4;CE9D;110F 1162 11B4; 
    // (캝; 캝; 캝; 캝; 캝; ) HANGUL SYLLABLE KAELT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE9D }};
        std::array<char32_t, 1> const c2 = {{ 0xCE9D }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE9D }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_078)
{
    // CE9E;CE9E;110F 1162 11B5;CE9E;110F 1162 11B5; 
    // (캞; 캞; 캞; 캞; 캞; ) HANGUL SYLLABLE KAELP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE9E }};
        std::array<char32_t, 1> const c2 = {{ 0xCE9E }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE9E }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_079)
{
    // CE9F;CE9F;110F 1162 11B6;CE9F;110F 1162 11B6; 
    // (캟; 캟; 캟; 캟; 캟; ) HANGUL SYLLABLE KAELH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCE9F }};
        std::array<char32_t, 1> const c2 = {{ 0xCE9F }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCE9F }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_080)
{
    // CEA0;CEA0;110F 1162 11B7;CEA0;110F 1162 11B7; 
    // (캠; 캠; 캠; 캠; 캠; ) HANGUL SYLLABLE KAEM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEA0 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEA0 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEA0 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_081)
{
    // CEA1;CEA1;110F 1162 11B8;CEA1;110F 1162 11B8; 
    // (캡; 캡; 캡; 캡; 캡; ) HANGUL SYLLABLE KAEB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEA1 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEA1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEA1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_082)
{
    // CEA2;CEA2;110F 1162 11B9;CEA2;110F 1162 11B9; 
    // (캢; 캢; 캢; 캢; 캢; ) HANGUL SYLLABLE KAEBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEA2 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEA2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEA2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_083)
{
    // CEA3;CEA3;110F 1162 11BA;CEA3;110F 1162 11BA; 
    // (캣; 캣; 캣; 캣; 캣; ) HANGUL SYLLABLE KAES
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEA3 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEA3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCEA3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_084)
{
    // CEA4;CEA4;110F 1162 11BB;CEA4;110F 1162 11BB; 
    // (캤; 캤; 캤; 캤; 캤; ) HANGUL SYLLABLE KAESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEA4 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEA4 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCEA4 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_085)
{
    // CEA5;CEA5;110F 1162 11BC;CEA5;110F 1162 11BC; 
    // (캥; 캥; 캥; 캥; 캥; ) HANGUL SYLLABLE KAENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEA5 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEA5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCEA5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_086)
{
    // CEA6;CEA6;110F 1162 11BD;CEA6;110F 1162 11BD; 
    // (캦; 캦; 캦; 캦; 캦; ) HANGUL SYLLABLE KAEJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEA6 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEA6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCEA6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_087)
{
    // CEA7;CEA7;110F 1162 11BE;CEA7;110F 1162 11BE; 
    // (캧; 캧; 캧; 캧; 캧; ) HANGUL SYLLABLE KAEC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEA7 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEA7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCEA7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_088)
{
    // CEA8;CEA8;110F 1162 11BF;CEA8;110F 1162 11BF; 
    // (캨; 캨; 캨; 캨; 캨; ) HANGUL SYLLABLE KAEK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEA8 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEA8 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCEA8 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_089)
{
    // CEA9;CEA9;110F 1162 11C0;CEA9;110F 1162 11C0; 
    // (캩; 캩; 캩; 캩; 캩; ) HANGUL SYLLABLE KAET
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEA9 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEA9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEA9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_090)
{
    // CEAA;CEAA;110F 1162 11C1;CEAA;110F 1162 11C1; 
    // (캪; 캪; 캪; 캪; 캪; ) HANGUL SYLLABLE KAEP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEAA }};
        std::array<char32_t, 1> const c2 = {{ 0xCEAA }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEAA }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_091)
{
    // CEAB;CEAB;110F 1162 11C2;CEAB;110F 1162 11C2; 
    // (캫; 캫; 캫; 캫; 캫; ) HANGUL SYLLABLE KAEH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEAB }};
        std::array<char32_t, 1> const c2 = {{ 0xCEAB }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1162, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEAB }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1162, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_092)
{
    // CEAC;CEAC;110F 1163;CEAC;110F 1163; 
    // (캬; 캬; 캬; 캬; 캬; ) HANGUL SYLLABLE KYA
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEAC }};
        std::array<char32_t, 1> const c2 = {{ 0xCEAC }};
        std::array<char32_t, 2> const c3 = {{ 0x110F, 0x1163 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEAC }};
        std::array<char32_t, 2> const c5 = {{ 0x110F, 0x1163 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_093)
{
    // CEAD;CEAD;110F 1163 11A8;CEAD;110F 1163 11A8; 
    // (캭; 캭; 캭; 캭; 캭; ) HANGUL SYLLABLE KYAG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEAD }};
        std::array<char32_t, 1> const c2 = {{ 0xCEAD }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEAD }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_094)
{
    // CEAE;CEAE;110F 1163 11A9;CEAE;110F 1163 11A9; 
    // (캮; 캮; 캮; 캮; 캮; ) HANGUL SYLLABLE KYAGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEAE }};
        std::array<char32_t, 1> const c2 = {{ 0xCEAE }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEAE }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_095)
{
    // CEAF;CEAF;110F 1163 11AA;CEAF;110F 1163 11AA; 
    // (캯; 캯; 캯; 캯; 캯; ) HANGUL SYLLABLE KYAGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEAF }};
        std::array<char32_t, 1> const c2 = {{ 0xCEAF }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCEAF }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_096)
{
    // CEB0;CEB0;110F 1163 11AB;CEB0;110F 1163 11AB; 
    // (캰; 캰; 캰; 캰; 캰; ) HANGUL SYLLABLE KYAN
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEB0 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEB0 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCEB0 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_097)
{
    // CEB1;CEB1;110F 1163 11AC;CEB1;110F 1163 11AC; 
    // (캱; 캱; 캱; 캱; 캱; ) HANGUL SYLLABLE KYANJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEB1 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEB1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCEB1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_098)
{
    // CEB2;CEB2;110F 1163 11AD;CEB2;110F 1163 11AD; 
    // (캲; 캲; 캲; 캲; 캲; ) HANGUL SYLLABLE KYANH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEB2 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEB2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCEB2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_099)
{
    // CEB3;CEB3;110F 1163 11AE;CEB3;110F 1163 11AE; 
    // (캳; 캳; 캳; 캳; 캳; ) HANGUL SYLLABLE KYAD
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEB3 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEB3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCEB3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_100)
{
    // CEB4;CEB4;110F 1163 11AF;CEB4;110F 1163 11AF; 
    // (캴; 캴; 캴; 캴; 캴; ) HANGUL SYLLABLE KYAL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEB4 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEB4 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCEB4 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_101)
{
    // CEB5;CEB5;110F 1163 11B0;CEB5;110F 1163 11B0; 
    // (캵; 캵; 캵; 캵; 캵; ) HANGUL SYLLABLE KYALG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEB5 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEB5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEB5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_102)
{
    // CEB6;CEB6;110F 1163 11B1;CEB6;110F 1163 11B1; 
    // (캶; 캶; 캶; 캶; 캶; ) HANGUL SYLLABLE KYALM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEB6 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEB6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEB6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_103)
{
    // CEB7;CEB7;110F 1163 11B2;CEB7;110F 1163 11B2; 
    // (캷; 캷; 캷; 캷; 캷; ) HANGUL SYLLABLE KYALB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEB7 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEB7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEB7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_104)
{
    // CEB8;CEB8;110F 1163 11B3;CEB8;110F 1163 11B3; 
    // (캸; 캸; 캸; 캸; 캸; ) HANGUL SYLLABLE KYALS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEB8 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEB8 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEB8 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_105)
{
    // CEB9;CEB9;110F 1163 11B4;CEB9;110F 1163 11B4; 
    // (캹; 캹; 캹; 캹; 캹; ) HANGUL SYLLABLE KYALT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEB9 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEB9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEB9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_106)
{
    // CEBA;CEBA;110F 1163 11B5;CEBA;110F 1163 11B5; 
    // (캺; 캺; 캺; 캺; 캺; ) HANGUL SYLLABLE KYALP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEBA }};
        std::array<char32_t, 1> const c2 = {{ 0xCEBA }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEBA }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_107)
{
    // CEBB;CEBB;110F 1163 11B6;CEBB;110F 1163 11B6; 
    // (캻; 캻; 캻; 캻; 캻; ) HANGUL SYLLABLE KYALH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEBB }};
        std::array<char32_t, 1> const c2 = {{ 0xCEBB }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEBB }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_108)
{
    // CEBC;CEBC;110F 1163 11B7;CEBC;110F 1163 11B7; 
    // (캼; 캼; 캼; 캼; 캼; ) HANGUL SYLLABLE KYAM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEBC }};
        std::array<char32_t, 1> const c2 = {{ 0xCEBC }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEBC }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_109)
{
    // CEBD;CEBD;110F 1163 11B8;CEBD;110F 1163 11B8; 
    // (캽; 캽; 캽; 캽; 캽; ) HANGUL SYLLABLE KYAB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEBD }};
        std::array<char32_t, 1> const c2 = {{ 0xCEBD }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEBD }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_110)
{
    // CEBE;CEBE;110F 1163 11B9;CEBE;110F 1163 11B9; 
    // (캾; 캾; 캾; 캾; 캾; ) HANGUL SYLLABLE KYABS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEBE }};
        std::array<char32_t, 1> const c2 = {{ 0xCEBE }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEBE }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_111)
{
    // CEBF;CEBF;110F 1163 11BA;CEBF;110F 1163 11BA; 
    // (캿; 캿; 캿; 캿; 캿; ) HANGUL SYLLABLE KYAS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEBF }};
        std::array<char32_t, 1> const c2 = {{ 0xCEBF }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCEBF }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_112)
{
    // CEC0;CEC0;110F 1163 11BB;CEC0;110F 1163 11BB; 
    // (컀; 컀; 컀; 컀; 컀; ) HANGUL SYLLABLE KYASS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEC0 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEC0 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCEC0 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_113)
{
    // CEC1;CEC1;110F 1163 11BC;CEC1;110F 1163 11BC; 
    // (컁; 컁; 컁; 컁; 컁; ) HANGUL SYLLABLE KYANG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEC1 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEC1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCEC1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_114)
{
    // CEC2;CEC2;110F 1163 11BD;CEC2;110F 1163 11BD; 
    // (컂; 컂; 컂; 컂; 컂; ) HANGUL SYLLABLE KYAJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEC2 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEC2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCEC2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_115)
{
    // CEC3;CEC3;110F 1163 11BE;CEC3;110F 1163 11BE; 
    // (컃; 컃; 컃; 컃; 컃; ) HANGUL SYLLABLE KYAC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEC3 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEC3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCEC3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_116)
{
    // CEC4;CEC4;110F 1163 11BF;CEC4;110F 1163 11BF; 
    // (컄; 컄; 컄; 컄; 컄; ) HANGUL SYLLABLE KYAK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEC4 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEC4 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCEC4 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_117)
{
    // CEC5;CEC5;110F 1163 11C0;CEC5;110F 1163 11C0; 
    // (컅; 컅; 컅; 컅; 컅; ) HANGUL SYLLABLE KYAT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEC5 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEC5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEC5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_118)
{
    // CEC6;CEC6;110F 1163 11C1;CEC6;110F 1163 11C1; 
    // (컆; 컆; 컆; 컆; 컆; ) HANGUL SYLLABLE KYAP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEC6 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEC6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEC6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_119)
{
    // CEC7;CEC7;110F 1163 11C2;CEC7;110F 1163 11C2; 
    // (컇; 컇; 컇; 컇; 컇; ) HANGUL SYLLABLE KYAH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEC7 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEC7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1163, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEC7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1163, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_120)
{
    // CEC8;CEC8;110F 1164;CEC8;110F 1164; 
    // (컈; 컈; 컈; 컈; 컈; ) HANGUL SYLLABLE KYAE
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEC8 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEC8 }};
        std::array<char32_t, 2> const c3 = {{ 0x110F, 0x1164 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEC8 }};
        std::array<char32_t, 2> const c5 = {{ 0x110F, 0x1164 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_121)
{
    // CEC9;CEC9;110F 1164 11A8;CEC9;110F 1164 11A8; 
    // (컉; 컉; 컉; 컉; 컉; ) HANGUL SYLLABLE KYAEG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEC9 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEC9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEC9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_122)
{
    // CECA;CECA;110F 1164 11A9;CECA;110F 1164 11A9; 
    // (컊; 컊; 컊; 컊; 컊; ) HANGUL SYLLABLE KYAEGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCECA }};
        std::array<char32_t, 1> const c2 = {{ 0xCECA }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCECA }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_123)
{
    // CECB;CECB;110F 1164 11AA;CECB;110F 1164 11AA; 
    // (컋; 컋; 컋; 컋; 컋; ) HANGUL SYLLABLE KYAEGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCECB }};
        std::array<char32_t, 1> const c2 = {{ 0xCECB }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCECB }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_124)
{
    // CECC;CECC;110F 1164 11AB;CECC;110F 1164 11AB; 
    // (컌; 컌; 컌; 컌; 컌; ) HANGUL SYLLABLE KYAEN
    {
        std::array<char32_t, 1> const c1 = {{ 0xCECC }};
        std::array<char32_t, 1> const c2 = {{ 0xCECC }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCECC }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_125)
{
    // CECD;CECD;110F 1164 11AC;CECD;110F 1164 11AC; 
    // (컍; 컍; 컍; 컍; 컍; ) HANGUL SYLLABLE KYAENJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCECD }};
        std::array<char32_t, 1> const c2 = {{ 0xCECD }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCECD }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_126)
{
    // CECE;CECE;110F 1164 11AD;CECE;110F 1164 11AD; 
    // (컎; 컎; 컎; 컎; 컎; ) HANGUL SYLLABLE KYAENH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCECE }};
        std::array<char32_t, 1> const c2 = {{ 0xCECE }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCECE }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_127)
{
    // CECF;CECF;110F 1164 11AE;CECF;110F 1164 11AE; 
    // (컏; 컏; 컏; 컏; 컏; ) HANGUL SYLLABLE KYAED
    {
        std::array<char32_t, 1> const c1 = {{ 0xCECF }};
        std::array<char32_t, 1> const c2 = {{ 0xCECF }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCECF }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_128)
{
    // CED0;CED0;110F 1164 11AF;CED0;110F 1164 11AF; 
    // (컐; 컐; 컐; 컐; 컐; ) HANGUL SYLLABLE KYAEL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCED0 }};
        std::array<char32_t, 1> const c2 = {{ 0xCED0 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCED0 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_129)
{
    // CED1;CED1;110F 1164 11B0;CED1;110F 1164 11B0; 
    // (컑; 컑; 컑; 컑; 컑; ) HANGUL SYLLABLE KYAELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCED1 }};
        std::array<char32_t, 1> const c2 = {{ 0xCED1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCED1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_130)
{
    // CED2;CED2;110F 1164 11B1;CED2;110F 1164 11B1; 
    // (컒; 컒; 컒; 컒; 컒; ) HANGUL SYLLABLE KYAELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCED2 }};
        std::array<char32_t, 1> const c2 = {{ 0xCED2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCED2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_131)
{
    // CED3;CED3;110F 1164 11B2;CED3;110F 1164 11B2; 
    // (컓; 컓; 컓; 컓; 컓; ) HANGUL SYLLABLE KYAELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCED3 }};
        std::array<char32_t, 1> const c2 = {{ 0xCED3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCED3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_132)
{
    // CED4;CED4;110F 1164 11B3;CED4;110F 1164 11B3; 
    // (컔; 컔; 컔; 컔; 컔; ) HANGUL SYLLABLE KYAELS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCED4 }};
        std::array<char32_t, 1> const c2 = {{ 0xCED4 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCED4 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_133)
{
    // CED5;CED5;110F 1164 11B4;CED5;110F 1164 11B4; 
    // (컕; 컕; 컕; 컕; 컕; ) HANGUL SYLLABLE KYAELT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCED5 }};
        std::array<char32_t, 1> const c2 = {{ 0xCED5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCED5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_134)
{
    // CED6;CED6;110F 1164 11B5;CED6;110F 1164 11B5; 
    // (컖; 컖; 컖; 컖; 컖; ) HANGUL SYLLABLE KYAELP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCED6 }};
        std::array<char32_t, 1> const c2 = {{ 0xCED6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCED6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_135)
{
    // CED7;CED7;110F 1164 11B6;CED7;110F 1164 11B6; 
    // (컗; 컗; 컗; 컗; 컗; ) HANGUL SYLLABLE KYAELH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCED7 }};
        std::array<char32_t, 1> const c2 = {{ 0xCED7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCED7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_136)
{
    // CED8;CED8;110F 1164 11B7;CED8;110F 1164 11B7; 
    // (컘; 컘; 컘; 컘; 컘; ) HANGUL SYLLABLE KYAEM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCED8 }};
        std::array<char32_t, 1> const c2 = {{ 0xCED8 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCED8 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_137)
{
    // CED9;CED9;110F 1164 11B8;CED9;110F 1164 11B8; 
    // (컙; 컙; 컙; 컙; 컙; ) HANGUL SYLLABLE KYAEB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCED9 }};
        std::array<char32_t, 1> const c2 = {{ 0xCED9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCED9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_138)
{
    // CEDA;CEDA;110F 1164 11B9;CEDA;110F 1164 11B9; 
    // (컚; 컚; 컚; 컚; 컚; ) HANGUL SYLLABLE KYAEBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEDA }};
        std::array<char32_t, 1> const c2 = {{ 0xCEDA }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEDA }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_139)
{
    // CEDB;CEDB;110F 1164 11BA;CEDB;110F 1164 11BA; 
    // (컛; 컛; 컛; 컛; 컛; ) HANGUL SYLLABLE KYAES
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEDB }};
        std::array<char32_t, 1> const c2 = {{ 0xCEDB }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCEDB }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_140)
{
    // CEDC;CEDC;110F 1164 11BB;CEDC;110F 1164 11BB; 
    // (컜; 컜; 컜; 컜; 컜; ) HANGUL SYLLABLE KYAESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEDC }};
        std::array<char32_t, 1> const c2 = {{ 0xCEDC }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCEDC }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_141)
{
    // CEDD;CEDD;110F 1164 11BC;CEDD;110F 1164 11BC; 
    // (컝; 컝; 컝; 컝; 컝; ) HANGUL SYLLABLE KYAENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEDD }};
        std::array<char32_t, 1> const c2 = {{ 0xCEDD }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCEDD }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_142)
{
    // CEDE;CEDE;110F 1164 11BD;CEDE;110F 1164 11BD; 
    // (컞; 컞; 컞; 컞; 컞; ) HANGUL SYLLABLE KYAEJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEDE }};
        std::array<char32_t, 1> const c2 = {{ 0xCEDE }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCEDE }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_143)
{
    // CEDF;CEDF;110F 1164 11BE;CEDF;110F 1164 11BE; 
    // (컟; 컟; 컟; 컟; 컟; ) HANGUL SYLLABLE KYAEC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEDF }};
        std::array<char32_t, 1> const c2 = {{ 0xCEDF }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCEDF }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_144)
{
    // CEE0;CEE0;110F 1164 11BF;CEE0;110F 1164 11BF; 
    // (컠; 컠; 컠; 컠; 컠; ) HANGUL SYLLABLE KYAEK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEE0 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEE0 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCEE0 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_145)
{
    // CEE1;CEE1;110F 1164 11C0;CEE1;110F 1164 11C0; 
    // (컡; 컡; 컡; 컡; 컡; ) HANGUL SYLLABLE KYAET
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEE1 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEE1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEE1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_146)
{
    // CEE2;CEE2;110F 1164 11C1;CEE2;110F 1164 11C1; 
    // (컢; 컢; 컢; 컢; 컢; ) HANGUL SYLLABLE KYAEP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEE2 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEE2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEE2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_147)
{
    // CEE3;CEE3;110F 1164 11C2;CEE3;110F 1164 11C2; 
    // (컣; 컣; 컣; 컣; 컣; ) HANGUL SYLLABLE KYAEH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEE3 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEE3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1164, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEE3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1164, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_148)
{
    // CEE4;CEE4;110F 1165;CEE4;110F 1165; 
    // (커; 커; 커; 커; 커; ) HANGUL SYLLABLE KEO
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEE4 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEE4 }};
        std::array<char32_t, 2> const c3 = {{ 0x110F, 0x1165 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEE4 }};
        std::array<char32_t, 2> const c5 = {{ 0x110F, 0x1165 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_149)
{
    // CEE5;CEE5;110F 1165 11A8;CEE5;110F 1165 11A8; 
    // (컥; 컥; 컥; 컥; 컥; ) HANGUL SYLLABLE KEOG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEE5 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEE5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEE5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_150)
{
    // CEE6;CEE6;110F 1165 11A9;CEE6;110F 1165 11A9; 
    // (컦; 컦; 컦; 컦; 컦; ) HANGUL SYLLABLE KEOGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEE6 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEE6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEE6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_151)
{
    // CEE7;CEE7;110F 1165 11AA;CEE7;110F 1165 11AA; 
    // (컧; 컧; 컧; 컧; 컧; ) HANGUL SYLLABLE KEOGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEE7 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEE7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCEE7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_152)
{
    // CEE8;CEE8;110F 1165 11AB;CEE8;110F 1165 11AB; 
    // (컨; 컨; 컨; 컨; 컨; ) HANGUL SYLLABLE KEON
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEE8 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEE8 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCEE8 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_153)
{
    // CEE9;CEE9;110F 1165 11AC;CEE9;110F 1165 11AC; 
    // (컩; 컩; 컩; 컩; 컩; ) HANGUL SYLLABLE KEONJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEE9 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEE9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCEE9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_154)
{
    // CEEA;CEEA;110F 1165 11AD;CEEA;110F 1165 11AD; 
    // (컪; 컪; 컪; 컪; 컪; ) HANGUL SYLLABLE KEONH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEEA }};
        std::array<char32_t, 1> const c2 = {{ 0xCEEA }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCEEA }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_155)
{
    // CEEB;CEEB;110F 1165 11AE;CEEB;110F 1165 11AE; 
    // (컫; 컫; 컫; 컫; 컫; ) HANGUL SYLLABLE KEOD
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEEB }};
        std::array<char32_t, 1> const c2 = {{ 0xCEEB }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCEEB }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_156)
{
    // CEEC;CEEC;110F 1165 11AF;CEEC;110F 1165 11AF; 
    // (컬; 컬; 컬; 컬; 컬; ) HANGUL SYLLABLE KEOL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEEC }};
        std::array<char32_t, 1> const c2 = {{ 0xCEEC }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCEEC }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_157)
{
    // CEED;CEED;110F 1165 11B0;CEED;110F 1165 11B0; 
    // (컭; 컭; 컭; 컭; 컭; ) HANGUL SYLLABLE KEOLG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEED }};
        std::array<char32_t, 1> const c2 = {{ 0xCEED }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEED }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_158)
{
    // CEEE;CEEE;110F 1165 11B1;CEEE;110F 1165 11B1; 
    // (컮; 컮; 컮; 컮; 컮; ) HANGUL SYLLABLE KEOLM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEEE }};
        std::array<char32_t, 1> const c2 = {{ 0xCEEE }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEEE }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_159)
{
    // CEEF;CEEF;110F 1165 11B2;CEEF;110F 1165 11B2; 
    // (컯; 컯; 컯; 컯; 컯; ) HANGUL SYLLABLE KEOLB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEEF }};
        std::array<char32_t, 1> const c2 = {{ 0xCEEF }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEEF }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_160)
{
    // CEF0;CEF0;110F 1165 11B3;CEF0;110F 1165 11B3; 
    // (컰; 컰; 컰; 컰; 컰; ) HANGUL SYLLABLE KEOLS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEF0 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEF0 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEF0 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_161)
{
    // CEF1;CEF1;110F 1165 11B4;CEF1;110F 1165 11B4; 
    // (컱; 컱; 컱; 컱; 컱; ) HANGUL SYLLABLE KEOLT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEF1 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEF1 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEF1 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_162)
{
    // CEF2;CEF2;110F 1165 11B5;CEF2;110F 1165 11B5; 
    // (컲; 컲; 컲; 컲; 컲; ) HANGUL SYLLABLE KEOLP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEF2 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEF2 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEF2 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_163)
{
    // CEF3;CEF3;110F 1165 11B6;CEF3;110F 1165 11B6; 
    // (컳; 컳; 컳; 컳; 컳; ) HANGUL SYLLABLE KEOLH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEF3 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEF3 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEF3 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_164)
{
    // CEF4;CEF4;110F 1165 11B7;CEF4;110F 1165 11B7; 
    // (컴; 컴; 컴; 컴; 컴; ) HANGUL SYLLABLE KEOM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEF4 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEF4 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEF4 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_165)
{
    // CEF5;CEF5;110F 1165 11B8;CEF5;110F 1165 11B8; 
    // (컵; 컵; 컵; 컵; 컵; ) HANGUL SYLLABLE KEOB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEF5 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEF5 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEF5 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_166)
{
    // CEF6;CEF6;110F 1165 11B9;CEF6;110F 1165 11B9; 
    // (컶; 컶; 컶; 컶; 컶; ) HANGUL SYLLABLE KEOBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEF6 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEF6 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEF6 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_167)
{
    // CEF7;CEF7;110F 1165 11BA;CEF7;110F 1165 11BA; 
    // (컷; 컷; 컷; 컷; 컷; ) HANGUL SYLLABLE KEOS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEF7 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEF7 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCEF7 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_168)
{
    // CEF8;CEF8;110F 1165 11BB;CEF8;110F 1165 11BB; 
    // (컸; 컸; 컸; 컸; 컸; ) HANGUL SYLLABLE KEOSS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEF8 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEF8 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCEF8 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_169)
{
    // CEF9;CEF9;110F 1165 11BC;CEF9;110F 1165 11BC; 
    // (컹; 컹; 컹; 컹; 컹; ) HANGUL SYLLABLE KEONG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEF9 }};
        std::array<char32_t, 1> const c2 = {{ 0xCEF9 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCEF9 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_170)
{
    // CEFA;CEFA;110F 1165 11BD;CEFA;110F 1165 11BD; 
    // (컺; 컺; 컺; 컺; 컺; ) HANGUL SYLLABLE KEOJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEFA }};
        std::array<char32_t, 1> const c2 = {{ 0xCEFA }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCEFA }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_171)
{
    // CEFB;CEFB;110F 1165 11BE;CEFB;110F 1165 11BE; 
    // (컻; 컻; 컻; 컻; 컻; ) HANGUL SYLLABLE KEOC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEFB }};
        std::array<char32_t, 1> const c2 = {{ 0xCEFB }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCEFB }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_172)
{
    // CEFC;CEFC;110F 1165 11BF;CEFC;110F 1165 11BF; 
    // (컼; 컼; 컼; 컼; 컼; ) HANGUL SYLLABLE KEOK
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEFC }};
        std::array<char32_t, 1> const c2 = {{ 0xCEFC }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11BF }};
        std::array<char32_t, 1> const c4 = {{ 0xCEFC }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11BF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_173)
{
    // CEFD;CEFD;110F 1165 11C0;CEFD;110F 1165 11C0; 
    // (컽; 컽; 컽; 컽; 컽; ) HANGUL SYLLABLE KEOT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEFD }};
        std::array<char32_t, 1> const c2 = {{ 0xCEFD }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11C0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEFD }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11C0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_174)
{
    // CEFE;CEFE;110F 1165 11C1;CEFE;110F 1165 11C1; 
    // (컾; 컾; 컾; 컾; 컾; ) HANGUL SYLLABLE KEOP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEFE }};
        std::array<char32_t, 1> const c2 = {{ 0xCEFE }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11C1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEFE }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11C1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_175)
{
    // CEFF;CEFF;110F 1165 11C2;CEFF;110F 1165 11C2; 
    // (컿; 컿; 컿; 컿; 컿; ) HANGUL SYLLABLE KEOH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCEFF }};
        std::array<char32_t, 1> const c2 = {{ 0xCEFF }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1165, 0x11C2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCEFF }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1165, 0x11C2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_176)
{
    // CF00;CF00;110F 1166;CF00;110F 1166; 
    // (케; 케; 케; 케; 케; ) HANGUL SYLLABLE KE
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF00 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF00 }};
        std::array<char32_t, 2> const c3 = {{ 0x110F, 0x1166 }};
        std::array<char32_t, 1> const c4 = {{ 0xCF00 }};
        std::array<char32_t, 2> const c5 = {{ 0x110F, 0x1166 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_177)
{
    // CF01;CF01;110F 1166 11A8;CF01;110F 1166 11A8; 
    // (켁; 켁; 켁; 켁; 켁; ) HANGUL SYLLABLE KEG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF01 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF01 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11A8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCF01 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11A8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_178)
{
    // CF02;CF02;110F 1166 11A9;CF02;110F 1166 11A9; 
    // (켂; 켂; 켂; 켂; 켂; ) HANGUL SYLLABLE KEGG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF02 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF02 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11A9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCF02 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11A9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_179)
{
    // CF03;CF03;110F 1166 11AA;CF03;110F 1166 11AA; 
    // (켃; 켃; 켃; 켃; 켃; ) HANGUL SYLLABLE KEGS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF03 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF03 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11AA }};
        std::array<char32_t, 1> const c4 = {{ 0xCF03 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11AA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_180)
{
    // CF04;CF04;110F 1166 11AB;CF04;110F 1166 11AB; 
    // (켄; 켄; 켄; 켄; 켄; ) HANGUL SYLLABLE KEN
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF04 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF04 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11AB }};
        std::array<char32_t, 1> const c4 = {{ 0xCF04 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11AB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_181)
{
    // CF05;CF05;110F 1166 11AC;CF05;110F 1166 11AC; 
    // (켅; 켅; 켅; 켅; 켅; ) HANGUL SYLLABLE KENJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF05 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF05 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11AC }};
        std::array<char32_t, 1> const c4 = {{ 0xCF05 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11AC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_182)
{
    // CF06;CF06;110F 1166 11AD;CF06;110F 1166 11AD; 
    // (켆; 켆; 켆; 켆; 켆; ) HANGUL SYLLABLE KENH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF06 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF06 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11AD }};
        std::array<char32_t, 1> const c4 = {{ 0xCF06 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11AD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_183)
{
    // CF07;CF07;110F 1166 11AE;CF07;110F 1166 11AE; 
    // (켇; 켇; 켇; 켇; 켇; ) HANGUL SYLLABLE KED
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF07 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF07 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11AE }};
        std::array<char32_t, 1> const c4 = {{ 0xCF07 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11AE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_184)
{
    // CF08;CF08;110F 1166 11AF;CF08;110F 1166 11AF; 
    // (켈; 켈; 켈; 켈; 켈; ) HANGUL SYLLABLE KEL
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF08 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF08 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11AF }};
        std::array<char32_t, 1> const c4 = {{ 0xCF08 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11AF }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_185)
{
    // CF09;CF09;110F 1166 11B0;CF09;110F 1166 11B0; 
    // (켉; 켉; 켉; 켉; 켉; ) HANGUL SYLLABLE KELG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF09 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF09 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11B0 }};
        std::array<char32_t, 1> const c4 = {{ 0xCF09 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11B0 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_186)
{
    // CF0A;CF0A;110F 1166 11B1;CF0A;110F 1166 11B1; 
    // (켊; 켊; 켊; 켊; 켊; ) HANGUL SYLLABLE KELM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF0A }};
        std::array<char32_t, 1> const c2 = {{ 0xCF0A }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11B1 }};
        std::array<char32_t, 1> const c4 = {{ 0xCF0A }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11B1 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_187)
{
    // CF0B;CF0B;110F 1166 11B2;CF0B;110F 1166 11B2; 
    // (켋; 켋; 켋; 켋; 켋; ) HANGUL SYLLABLE KELB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF0B }};
        std::array<char32_t, 1> const c2 = {{ 0xCF0B }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11B2 }};
        std::array<char32_t, 1> const c4 = {{ 0xCF0B }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11B2 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_188)
{
    // CF0C;CF0C;110F 1166 11B3;CF0C;110F 1166 11B3; 
    // (켌; 켌; 켌; 켌; 켌; ) HANGUL SYLLABLE KELS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF0C }};
        std::array<char32_t, 1> const c2 = {{ 0xCF0C }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11B3 }};
        std::array<char32_t, 1> const c4 = {{ 0xCF0C }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11B3 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_189)
{
    // CF0D;CF0D;110F 1166 11B4;CF0D;110F 1166 11B4; 
    // (켍; 켍; 켍; 켍; 켍; ) HANGUL SYLLABLE KELT
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF0D }};
        std::array<char32_t, 1> const c2 = {{ 0xCF0D }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11B4 }};
        std::array<char32_t, 1> const c4 = {{ 0xCF0D }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11B4 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_190)
{
    // CF0E;CF0E;110F 1166 11B5;CF0E;110F 1166 11B5; 
    // (켎; 켎; 켎; 켎; 켎; ) HANGUL SYLLABLE KELP
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF0E }};
        std::array<char32_t, 1> const c2 = {{ 0xCF0E }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11B5 }};
        std::array<char32_t, 1> const c4 = {{ 0xCF0E }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11B5 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_191)
{
    // CF0F;CF0F;110F 1166 11B6;CF0F;110F 1166 11B6; 
    // (켏; 켏; 켏; 켏; 켏; ) HANGUL SYLLABLE KELH
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF0F }};
        std::array<char32_t, 1> const c2 = {{ 0xCF0F }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11B6 }};
        std::array<char32_t, 1> const c4 = {{ 0xCF0F }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11B6 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_192)
{
    // CF10;CF10;110F 1166 11B7;CF10;110F 1166 11B7; 
    // (켐; 켐; 켐; 켐; 켐; ) HANGUL SYLLABLE KEM
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF10 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF10 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11B7 }};
        std::array<char32_t, 1> const c4 = {{ 0xCF10 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11B7 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_193)
{
    // CF11;CF11;110F 1166 11B8;CF11;110F 1166 11B8; 
    // (켑; 켑; 켑; 켑; 켑; ) HANGUL SYLLABLE KEB
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF11 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF11 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11B8 }};
        std::array<char32_t, 1> const c4 = {{ 0xCF11 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11B8 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_194)
{
    // CF12;CF12;110F 1166 11B9;CF12;110F 1166 11B9; 
    // (켒; 켒; 켒; 켒; 켒; ) HANGUL SYLLABLE KEBS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF12 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF12 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11B9 }};
        std::array<char32_t, 1> const c4 = {{ 0xCF12 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11B9 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_195)
{
    // CF13;CF13;110F 1166 11BA;CF13;110F 1166 11BA; 
    // (켓; 켓; 켓; 켓; 켓; ) HANGUL SYLLABLE KES
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF13 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF13 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11BA }};
        std::array<char32_t, 1> const c4 = {{ 0xCF13 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11BA }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_196)
{
    // CF14;CF14;110F 1166 11BB;CF14;110F 1166 11BB; 
    // (켔; 켔; 켔; 켔; 켔; ) HANGUL SYLLABLE KESS
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF14 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF14 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11BB }};
        std::array<char32_t, 1> const c4 = {{ 0xCF14 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11BB }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_197)
{
    // CF15;CF15;110F 1166 11BC;CF15;110F 1166 11BC; 
    // (켕; 켕; 켕; 켕; 켕; ) HANGUL SYLLABLE KENG
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF15 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF15 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11BC }};
        std::array<char32_t, 1> const c4 = {{ 0xCF15 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11BC }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_198)
{
    // CF16;CF16;110F 1166 11BD;CF16;110F 1166 11BD; 
    // (켖; 켖; 켖; 켖; 켖; ) HANGUL SYLLABLE KEJ
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF16 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF16 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11BD }};
        std::array<char32_t, 1> const c4 = {{ 0xCF16 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11BD }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfc_056_199)
{
    // CF17;CF17;110F 1166 11BE;CF17;110F 1166 11BE; 
    // (켗; 켗; 켗; 켗; 켗; ) HANGUL SYLLABLE KEC
    {
        std::array<char32_t, 1> const c1 = {{ 0xCF17 }};
        std::array<char32_t, 1> const c2 = {{ 0xCF17 }};
        std::array<char32_t, 3> const c3 = {{ 0x110F, 0x1166, 0x11BE }};
        std::array<char32_t, 1> const c4 = {{ 0xCF17 }};
        std::array<char32_t, 3> const c5 = {{ 0x110F, 0x1166, 0x11BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c2.size());
                auto c2_it = c2.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c2_it) << "iteration " << i;
                    ++c2_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::c>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


