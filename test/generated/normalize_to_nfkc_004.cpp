// Copyright (C) 2020 T. Zachary Laine
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// Warning! This file is autogenerated.
#include <boost/text/normalize_string.hpp>
#include <boost/text/transcode_view.hpp>
#include <boost/text/string_utility.hpp>

#include <gtest/gtest.h>

#include <algorithm>



TEST(normalization, nfkc_004_000)
{
    // 1E89;1E89;0077 0323;1E89;0077 0323; 
    // (ẉ; ẉ; w◌̣; ẉ; w◌̣; ) LATIN SMALL LETTER W WITH DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E89 }};
        std::array<char32_t, 1> const c2 = {{ 0x1E89 }};
        std::array<char32_t, 2> const c3 = {{ 0x0077, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1E89 }};
        std::array<char32_t, 2> const c5 = {{ 0x0077, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_001)
{
    // 1E8A;1E8A;0058 0307;1E8A;0058 0307; 
    // (Ẋ; Ẋ; X◌̇; Ẋ; X◌̇; ) LATIN CAPITAL LETTER X WITH DOT ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E8A }};
        std::array<char32_t, 1> const c2 = {{ 0x1E8A }};
        std::array<char32_t, 2> const c3 = {{ 0x0058, 0x0307 }};
        std::array<char32_t, 1> const c4 = {{ 0x1E8A }};
        std::array<char32_t, 2> const c5 = {{ 0x0058, 0x0307 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_002)
{
    // 1E8B;1E8B;0078 0307;1E8B;0078 0307; 
    // (ẋ; ẋ; x◌̇; ẋ; x◌̇; ) LATIN SMALL LETTER X WITH DOT ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E8B }};
        std::array<char32_t, 1> const c2 = {{ 0x1E8B }};
        std::array<char32_t, 2> const c3 = {{ 0x0078, 0x0307 }};
        std::array<char32_t, 1> const c4 = {{ 0x1E8B }};
        std::array<char32_t, 2> const c5 = {{ 0x0078, 0x0307 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_003)
{
    // 1E8C;1E8C;0058 0308;1E8C;0058 0308; 
    // (Ẍ; Ẍ; X◌̈; Ẍ; X◌̈; ) LATIN CAPITAL LETTER X WITH DIAERESIS
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E8C }};
        std::array<char32_t, 1> const c2 = {{ 0x1E8C }};
        std::array<char32_t, 2> const c3 = {{ 0x0058, 0x0308 }};
        std::array<char32_t, 1> const c4 = {{ 0x1E8C }};
        std::array<char32_t, 2> const c5 = {{ 0x0058, 0x0308 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_004)
{
    // 1E8D;1E8D;0078 0308;1E8D;0078 0308; 
    // (ẍ; ẍ; x◌̈; ẍ; x◌̈; ) LATIN SMALL LETTER X WITH DIAERESIS
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E8D }};
        std::array<char32_t, 1> const c2 = {{ 0x1E8D }};
        std::array<char32_t, 2> const c3 = {{ 0x0078, 0x0308 }};
        std::array<char32_t, 1> const c4 = {{ 0x1E8D }};
        std::array<char32_t, 2> const c5 = {{ 0x0078, 0x0308 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_005)
{
    // 1E8E;1E8E;0059 0307;1E8E;0059 0307; 
    // (Ẏ; Ẏ; Y◌̇; Ẏ; Y◌̇; ) LATIN CAPITAL LETTER Y WITH DOT ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E8E }};
        std::array<char32_t, 1> const c2 = {{ 0x1E8E }};
        std::array<char32_t, 2> const c3 = {{ 0x0059, 0x0307 }};
        std::array<char32_t, 1> const c4 = {{ 0x1E8E }};
        std::array<char32_t, 2> const c5 = {{ 0x0059, 0x0307 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_006)
{
    // 1E8F;1E8F;0079 0307;1E8F;0079 0307; 
    // (ẏ; ẏ; y◌̇; ẏ; y◌̇; ) LATIN SMALL LETTER Y WITH DOT ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E8F }};
        std::array<char32_t, 1> const c2 = {{ 0x1E8F }};
        std::array<char32_t, 2> const c3 = {{ 0x0079, 0x0307 }};
        std::array<char32_t, 1> const c4 = {{ 0x1E8F }};
        std::array<char32_t, 2> const c5 = {{ 0x0079, 0x0307 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_007)
{
    // 1E90;1E90;005A 0302;1E90;005A 0302; 
    // (Ẑ; Ẑ; Z◌̂; Ẑ; Z◌̂; ) LATIN CAPITAL LETTER Z WITH CIRCUMFLEX
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E90 }};
        std::array<char32_t, 1> const c2 = {{ 0x1E90 }};
        std::array<char32_t, 2> const c3 = {{ 0x005A, 0x0302 }};
        std::array<char32_t, 1> const c4 = {{ 0x1E90 }};
        std::array<char32_t, 2> const c5 = {{ 0x005A, 0x0302 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_008)
{
    // 1E91;1E91;007A 0302;1E91;007A 0302; 
    // (ẑ; ẑ; z◌̂; ẑ; z◌̂; ) LATIN SMALL LETTER Z WITH CIRCUMFLEX
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E91 }};
        std::array<char32_t, 1> const c2 = {{ 0x1E91 }};
        std::array<char32_t, 2> const c3 = {{ 0x007A, 0x0302 }};
        std::array<char32_t, 1> const c4 = {{ 0x1E91 }};
        std::array<char32_t, 2> const c5 = {{ 0x007A, 0x0302 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_009)
{
    // 1E92;1E92;005A 0323;1E92;005A 0323; 
    // (Ẓ; Ẓ; Z◌̣; Ẓ; Z◌̣; ) LATIN CAPITAL LETTER Z WITH DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E92 }};
        std::array<char32_t, 1> const c2 = {{ 0x1E92 }};
        std::array<char32_t, 2> const c3 = {{ 0x005A, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1E92 }};
        std::array<char32_t, 2> const c5 = {{ 0x005A, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_010)
{
    // 1E93;1E93;007A 0323;1E93;007A 0323; 
    // (ẓ; ẓ; z◌̣; ẓ; z◌̣; ) LATIN SMALL LETTER Z WITH DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E93 }};
        std::array<char32_t, 1> const c2 = {{ 0x1E93 }};
        std::array<char32_t, 2> const c3 = {{ 0x007A, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1E93 }};
        std::array<char32_t, 2> const c5 = {{ 0x007A, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_011)
{
    // 1E94;1E94;005A 0331;1E94;005A 0331; 
    // (Ẕ; Ẕ; Z◌̱; Ẕ; Z◌̱; ) LATIN CAPITAL LETTER Z WITH LINE BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E94 }};
        std::array<char32_t, 1> const c2 = {{ 0x1E94 }};
        std::array<char32_t, 2> const c3 = {{ 0x005A, 0x0331 }};
        std::array<char32_t, 1> const c4 = {{ 0x1E94 }};
        std::array<char32_t, 2> const c5 = {{ 0x005A, 0x0331 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_012)
{
    // 1E95;1E95;007A 0331;1E95;007A 0331; 
    // (ẕ; ẕ; z◌̱; ẕ; z◌̱; ) LATIN SMALL LETTER Z WITH LINE BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E95 }};
        std::array<char32_t, 1> const c2 = {{ 0x1E95 }};
        std::array<char32_t, 2> const c3 = {{ 0x007A, 0x0331 }};
        std::array<char32_t, 1> const c4 = {{ 0x1E95 }};
        std::array<char32_t, 2> const c5 = {{ 0x007A, 0x0331 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_013)
{
    // 1E96;1E96;0068 0331;1E96;0068 0331; 
    // (ẖ; ẖ; h◌̱; ẖ; h◌̱; ) LATIN SMALL LETTER H WITH LINE BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E96 }};
        std::array<char32_t, 1> const c2 = {{ 0x1E96 }};
        std::array<char32_t, 2> const c3 = {{ 0x0068, 0x0331 }};
        std::array<char32_t, 1> const c4 = {{ 0x1E96 }};
        std::array<char32_t, 2> const c5 = {{ 0x0068, 0x0331 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_014)
{
    // 1E97;1E97;0074 0308;1E97;0074 0308; 
    // (ẗ; ẗ; t◌̈; ẗ; t◌̈; ) LATIN SMALL LETTER T WITH DIAERESIS
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E97 }};
        std::array<char32_t, 1> const c2 = {{ 0x1E97 }};
        std::array<char32_t, 2> const c3 = {{ 0x0074, 0x0308 }};
        std::array<char32_t, 1> const c4 = {{ 0x1E97 }};
        std::array<char32_t, 2> const c5 = {{ 0x0074, 0x0308 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_015)
{
    // 1E98;1E98;0077 030A;1E98;0077 030A; 
    // (ẘ; ẘ; w◌̊; ẘ; w◌̊; ) LATIN SMALL LETTER W WITH RING ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E98 }};
        std::array<char32_t, 1> const c2 = {{ 0x1E98 }};
        std::array<char32_t, 2> const c3 = {{ 0x0077, 0x030A }};
        std::array<char32_t, 1> const c4 = {{ 0x1E98 }};
        std::array<char32_t, 2> const c5 = {{ 0x0077, 0x030A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_016)
{
    // 1E99;1E99;0079 030A;1E99;0079 030A; 
    // (ẙ; ẙ; y◌̊; ẙ; y◌̊; ) LATIN SMALL LETTER Y WITH RING ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E99 }};
        std::array<char32_t, 1> const c2 = {{ 0x1E99 }};
        std::array<char32_t, 2> const c3 = {{ 0x0079, 0x030A }};
        std::array<char32_t, 1> const c4 = {{ 0x1E99 }};
        std::array<char32_t, 2> const c5 = {{ 0x0079, 0x030A }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_017)
{
    // 1E9A;1E9A;1E9A;0061 02BE;0061 02BE; 
    // (ẚ; ẚ; ẚ; aʾ; aʾ; ) LATIN SMALL LETTER A WITH RIGHT HALF RING
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E9A }};
        std::array<char32_t, 1> const c2 = {{ 0x1E9A }};
        std::array<char32_t, 1> const c3 = {{ 0x1E9A }};
        std::array<char32_t, 2> const c4 = {{ 0x0061, 0x02BE }};
        std::array<char32_t, 2> const c5 = {{ 0x0061, 0x02BE }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_018)
{
    // 1E9B;1E9B;017F 0307;1E61;0073 0307; 
    // (ẛ; ẛ; ſ◌̇; ṡ; s◌̇; ) LATIN SMALL LETTER LONG S WITH DOT ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1E9B }};
        std::array<char32_t, 1> const c2 = {{ 0x1E9B }};
        std::array<char32_t, 2> const c3 = {{ 0x017F, 0x0307 }};
        std::array<char32_t, 1> const c4 = {{ 0x1E61 }};
        std::array<char32_t, 2> const c5 = {{ 0x0073, 0x0307 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_019)
{
    // 1EA0;1EA0;0041 0323;1EA0;0041 0323; 
    // (Ạ; Ạ; A◌̣; Ạ; A◌̣; ) LATIN CAPITAL LETTER A WITH DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EA0 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EA0 }};
        std::array<char32_t, 2> const c3 = {{ 0x0041, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EA0 }};
        std::array<char32_t, 2> const c5 = {{ 0x0041, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_020)
{
    // 1EA1;1EA1;0061 0323;1EA1;0061 0323; 
    // (ạ; ạ; a◌̣; ạ; a◌̣; ) LATIN SMALL LETTER A WITH DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EA1 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EA1 }};
        std::array<char32_t, 2> const c3 = {{ 0x0061, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EA1 }};
        std::array<char32_t, 2> const c5 = {{ 0x0061, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_021)
{
    // 1EA2;1EA2;0041 0309;1EA2;0041 0309; 
    // (Ả; Ả; A◌̉; Ả; A◌̉; ) LATIN CAPITAL LETTER A WITH HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EA2 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EA2 }};
        std::array<char32_t, 2> const c3 = {{ 0x0041, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EA2 }};
        std::array<char32_t, 2> const c5 = {{ 0x0041, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_022)
{
    // 1EA3;1EA3;0061 0309;1EA3;0061 0309; 
    // (ả; ả; a◌̉; ả; a◌̉; ) LATIN SMALL LETTER A WITH HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EA3 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EA3 }};
        std::array<char32_t, 2> const c3 = {{ 0x0061, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EA3 }};
        std::array<char32_t, 2> const c5 = {{ 0x0061, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_023)
{
    // 1EA4;1EA4;0041 0302 0301;1EA4;0041 0302 0301; 
    // (Ấ; Ấ; A◌̂◌́; Ấ; A◌̂◌́; ) LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EA4 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EA4 }};
        std::array<char32_t, 3> const c3 = {{ 0x0041, 0x0302, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EA4 }};
        std::array<char32_t, 3> const c5 = {{ 0x0041, 0x0302, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_024)
{
    // 1EA5;1EA5;0061 0302 0301;1EA5;0061 0302 0301; 
    // (ấ; ấ; a◌̂◌́; ấ; a◌̂◌́; ) LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EA5 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EA5 }};
        std::array<char32_t, 3> const c3 = {{ 0x0061, 0x0302, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EA5 }};
        std::array<char32_t, 3> const c5 = {{ 0x0061, 0x0302, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_025)
{
    // 1EA6;1EA6;0041 0302 0300;1EA6;0041 0302 0300; 
    // (Ầ; Ầ; A◌̂◌̀; Ầ; A◌̂◌̀; ) LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EA6 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EA6 }};
        std::array<char32_t, 3> const c3 = {{ 0x0041, 0x0302, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EA6 }};
        std::array<char32_t, 3> const c5 = {{ 0x0041, 0x0302, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_026)
{
    // 1EA7;1EA7;0061 0302 0300;1EA7;0061 0302 0300; 
    // (ầ; ầ; a◌̂◌̀; ầ; a◌̂◌̀; ) LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EA7 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EA7 }};
        std::array<char32_t, 3> const c3 = {{ 0x0061, 0x0302, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EA7 }};
        std::array<char32_t, 3> const c5 = {{ 0x0061, 0x0302, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_027)
{
    // 1EA8;1EA8;0041 0302 0309;1EA8;0041 0302 0309; 
    // (Ẩ; Ẩ; A◌̂◌̉; Ẩ; A◌̂◌̉; ) LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EA8 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EA8 }};
        std::array<char32_t, 3> const c3 = {{ 0x0041, 0x0302, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EA8 }};
        std::array<char32_t, 3> const c5 = {{ 0x0041, 0x0302, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_028)
{
    // 1EA9;1EA9;0061 0302 0309;1EA9;0061 0302 0309; 
    // (ẩ; ẩ; a◌̂◌̉; ẩ; a◌̂◌̉; ) LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EA9 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EA9 }};
        std::array<char32_t, 3> const c3 = {{ 0x0061, 0x0302, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EA9 }};
        std::array<char32_t, 3> const c5 = {{ 0x0061, 0x0302, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_029)
{
    // 1EAA;1EAA;0041 0302 0303;1EAA;0041 0302 0303; 
    // (Ẫ; Ẫ; A◌̂◌̃; Ẫ; A◌̂◌̃; ) LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EAA }};
        std::array<char32_t, 1> const c2 = {{ 0x1EAA }};
        std::array<char32_t, 3> const c3 = {{ 0x0041, 0x0302, 0x0303 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EAA }};
        std::array<char32_t, 3> const c5 = {{ 0x0041, 0x0302, 0x0303 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_030)
{
    // 1EAB;1EAB;0061 0302 0303;1EAB;0061 0302 0303; 
    // (ẫ; ẫ; a◌̂◌̃; ẫ; a◌̂◌̃; ) LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EAB }};
        std::array<char32_t, 1> const c2 = {{ 0x1EAB }};
        std::array<char32_t, 3> const c3 = {{ 0x0061, 0x0302, 0x0303 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EAB }};
        std::array<char32_t, 3> const c5 = {{ 0x0061, 0x0302, 0x0303 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_031)
{
    // 1EAC;1EAC;0041 0323 0302;1EAC;0041 0323 0302; 
    // (Ậ; Ậ; A◌̣◌̂; Ậ; A◌̣◌̂; ) LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EAC }};
        std::array<char32_t, 1> const c2 = {{ 0x1EAC }};
        std::array<char32_t, 3> const c3 = {{ 0x0041, 0x0323, 0x0302 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EAC }};
        std::array<char32_t, 3> const c5 = {{ 0x0041, 0x0323, 0x0302 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_032)
{
    // 1EAD;1EAD;0061 0323 0302;1EAD;0061 0323 0302; 
    // (ậ; ậ; a◌̣◌̂; ậ; a◌̣◌̂; ) LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EAD }};
        std::array<char32_t, 1> const c2 = {{ 0x1EAD }};
        std::array<char32_t, 3> const c3 = {{ 0x0061, 0x0323, 0x0302 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EAD }};
        std::array<char32_t, 3> const c5 = {{ 0x0061, 0x0323, 0x0302 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_033)
{
    // 1EAE;1EAE;0041 0306 0301;1EAE;0041 0306 0301; 
    // (Ắ; Ắ; A◌̆◌́; Ắ; A◌̆◌́; ) LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EAE }};
        std::array<char32_t, 1> const c2 = {{ 0x1EAE }};
        std::array<char32_t, 3> const c3 = {{ 0x0041, 0x0306, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EAE }};
        std::array<char32_t, 3> const c5 = {{ 0x0041, 0x0306, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_034)
{
    // 1EAF;1EAF;0061 0306 0301;1EAF;0061 0306 0301; 
    // (ắ; ắ; a◌̆◌́; ắ; a◌̆◌́; ) LATIN SMALL LETTER A WITH BREVE AND ACUTE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EAF }};
        std::array<char32_t, 1> const c2 = {{ 0x1EAF }};
        std::array<char32_t, 3> const c3 = {{ 0x0061, 0x0306, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EAF }};
        std::array<char32_t, 3> const c5 = {{ 0x0061, 0x0306, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_035)
{
    // 1EB0;1EB0;0041 0306 0300;1EB0;0041 0306 0300; 
    // (Ằ; Ằ; A◌̆◌̀; Ằ; A◌̆◌̀; ) LATIN CAPITAL LETTER A WITH BREVE AND GRAVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EB0 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EB0 }};
        std::array<char32_t, 3> const c3 = {{ 0x0041, 0x0306, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EB0 }};
        std::array<char32_t, 3> const c5 = {{ 0x0041, 0x0306, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_036)
{
    // 1EB1;1EB1;0061 0306 0300;1EB1;0061 0306 0300; 
    // (ằ; ằ; a◌̆◌̀; ằ; a◌̆◌̀; ) LATIN SMALL LETTER A WITH BREVE AND GRAVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EB1 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EB1 }};
        std::array<char32_t, 3> const c3 = {{ 0x0061, 0x0306, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EB1 }};
        std::array<char32_t, 3> const c5 = {{ 0x0061, 0x0306, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_037)
{
    // 1EB2;1EB2;0041 0306 0309;1EB2;0041 0306 0309; 
    // (Ẳ; Ẳ; A◌̆◌̉; Ẳ; A◌̆◌̉; ) LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EB2 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EB2 }};
        std::array<char32_t, 3> const c3 = {{ 0x0041, 0x0306, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EB2 }};
        std::array<char32_t, 3> const c5 = {{ 0x0041, 0x0306, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_038)
{
    // 1EB3;1EB3;0061 0306 0309;1EB3;0061 0306 0309; 
    // (ẳ; ẳ; a◌̆◌̉; ẳ; a◌̆◌̉; ) LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EB3 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EB3 }};
        std::array<char32_t, 3> const c3 = {{ 0x0061, 0x0306, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EB3 }};
        std::array<char32_t, 3> const c5 = {{ 0x0061, 0x0306, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_039)
{
    // 1EB4;1EB4;0041 0306 0303;1EB4;0041 0306 0303; 
    // (Ẵ; Ẵ; A◌̆◌̃; Ẵ; A◌̆◌̃; ) LATIN CAPITAL LETTER A WITH BREVE AND TILDE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EB4 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EB4 }};
        std::array<char32_t, 3> const c3 = {{ 0x0041, 0x0306, 0x0303 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EB4 }};
        std::array<char32_t, 3> const c5 = {{ 0x0041, 0x0306, 0x0303 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_040)
{
    // 1EB5;1EB5;0061 0306 0303;1EB5;0061 0306 0303; 
    // (ẵ; ẵ; a◌̆◌̃; ẵ; a◌̆◌̃; ) LATIN SMALL LETTER A WITH BREVE AND TILDE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EB5 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EB5 }};
        std::array<char32_t, 3> const c3 = {{ 0x0061, 0x0306, 0x0303 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EB5 }};
        std::array<char32_t, 3> const c5 = {{ 0x0061, 0x0306, 0x0303 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_041)
{
    // 1EB6;1EB6;0041 0323 0306;1EB6;0041 0323 0306; 
    // (Ặ; Ặ; A◌̣◌̆; Ặ; A◌̣◌̆; ) LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EB6 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EB6 }};
        std::array<char32_t, 3> const c3 = {{ 0x0041, 0x0323, 0x0306 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EB6 }};
        std::array<char32_t, 3> const c5 = {{ 0x0041, 0x0323, 0x0306 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_042)
{
    // 1EB7;1EB7;0061 0323 0306;1EB7;0061 0323 0306; 
    // (ặ; ặ; a◌̣◌̆; ặ; a◌̣◌̆; ) LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EB7 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EB7 }};
        std::array<char32_t, 3> const c3 = {{ 0x0061, 0x0323, 0x0306 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EB7 }};
        std::array<char32_t, 3> const c5 = {{ 0x0061, 0x0323, 0x0306 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_043)
{
    // 1EB8;1EB8;0045 0323;1EB8;0045 0323; 
    // (Ẹ; Ẹ; E◌̣; Ẹ; E◌̣; ) LATIN CAPITAL LETTER E WITH DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EB8 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EB8 }};
        std::array<char32_t, 2> const c3 = {{ 0x0045, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EB8 }};
        std::array<char32_t, 2> const c5 = {{ 0x0045, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_044)
{
    // 1EB9;1EB9;0065 0323;1EB9;0065 0323; 
    // (ẹ; ẹ; e◌̣; ẹ; e◌̣; ) LATIN SMALL LETTER E WITH DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EB9 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EB9 }};
        std::array<char32_t, 2> const c3 = {{ 0x0065, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EB9 }};
        std::array<char32_t, 2> const c5 = {{ 0x0065, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_045)
{
    // 1EBA;1EBA;0045 0309;1EBA;0045 0309; 
    // (Ẻ; Ẻ; E◌̉; Ẻ; E◌̉; ) LATIN CAPITAL LETTER E WITH HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EBA }};
        std::array<char32_t, 1> const c2 = {{ 0x1EBA }};
        std::array<char32_t, 2> const c3 = {{ 0x0045, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EBA }};
        std::array<char32_t, 2> const c5 = {{ 0x0045, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_046)
{
    // 1EBB;1EBB;0065 0309;1EBB;0065 0309; 
    // (ẻ; ẻ; e◌̉; ẻ; e◌̉; ) LATIN SMALL LETTER E WITH HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EBB }};
        std::array<char32_t, 1> const c2 = {{ 0x1EBB }};
        std::array<char32_t, 2> const c3 = {{ 0x0065, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EBB }};
        std::array<char32_t, 2> const c5 = {{ 0x0065, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_047)
{
    // 1EBC;1EBC;0045 0303;1EBC;0045 0303; 
    // (Ẽ; Ẽ; E◌̃; Ẽ; E◌̃; ) LATIN CAPITAL LETTER E WITH TILDE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EBC }};
        std::array<char32_t, 1> const c2 = {{ 0x1EBC }};
        std::array<char32_t, 2> const c3 = {{ 0x0045, 0x0303 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EBC }};
        std::array<char32_t, 2> const c5 = {{ 0x0045, 0x0303 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_048)
{
    // 1EBD;1EBD;0065 0303;1EBD;0065 0303; 
    // (ẽ; ẽ; e◌̃; ẽ; e◌̃; ) LATIN SMALL LETTER E WITH TILDE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EBD }};
        std::array<char32_t, 1> const c2 = {{ 0x1EBD }};
        std::array<char32_t, 2> const c3 = {{ 0x0065, 0x0303 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EBD }};
        std::array<char32_t, 2> const c5 = {{ 0x0065, 0x0303 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_049)
{
    // 1EBE;1EBE;0045 0302 0301;1EBE;0045 0302 0301; 
    // (Ế; Ế; E◌̂◌́; Ế; E◌̂◌́; ) LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EBE }};
        std::array<char32_t, 1> const c2 = {{ 0x1EBE }};
        std::array<char32_t, 3> const c3 = {{ 0x0045, 0x0302, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EBE }};
        std::array<char32_t, 3> const c5 = {{ 0x0045, 0x0302, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_050)
{
    // 1EBF;1EBF;0065 0302 0301;1EBF;0065 0302 0301; 
    // (ế; ế; e◌̂◌́; ế; e◌̂◌́; ) LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EBF }};
        std::array<char32_t, 1> const c2 = {{ 0x1EBF }};
        std::array<char32_t, 3> const c3 = {{ 0x0065, 0x0302, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EBF }};
        std::array<char32_t, 3> const c5 = {{ 0x0065, 0x0302, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_051)
{
    // 1EC0;1EC0;0045 0302 0300;1EC0;0045 0302 0300; 
    // (Ề; Ề; E◌̂◌̀; Ề; E◌̂◌̀; ) LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EC0 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EC0 }};
        std::array<char32_t, 3> const c3 = {{ 0x0045, 0x0302, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EC0 }};
        std::array<char32_t, 3> const c5 = {{ 0x0045, 0x0302, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_052)
{
    // 1EC1;1EC1;0065 0302 0300;1EC1;0065 0302 0300; 
    // (ề; ề; e◌̂◌̀; ề; e◌̂◌̀; ) LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EC1 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EC1 }};
        std::array<char32_t, 3> const c3 = {{ 0x0065, 0x0302, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EC1 }};
        std::array<char32_t, 3> const c5 = {{ 0x0065, 0x0302, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_053)
{
    // 1EC2;1EC2;0045 0302 0309;1EC2;0045 0302 0309; 
    // (Ể; Ể; E◌̂◌̉; Ể; E◌̂◌̉; ) LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EC2 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EC2 }};
        std::array<char32_t, 3> const c3 = {{ 0x0045, 0x0302, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EC2 }};
        std::array<char32_t, 3> const c5 = {{ 0x0045, 0x0302, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_054)
{
    // 1EC3;1EC3;0065 0302 0309;1EC3;0065 0302 0309; 
    // (ể; ể; e◌̂◌̉; ể; e◌̂◌̉; ) LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EC3 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EC3 }};
        std::array<char32_t, 3> const c3 = {{ 0x0065, 0x0302, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EC3 }};
        std::array<char32_t, 3> const c5 = {{ 0x0065, 0x0302, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_055)
{
    // 1EC4;1EC4;0045 0302 0303;1EC4;0045 0302 0303; 
    // (Ễ; Ễ; E◌̂◌̃; Ễ; E◌̂◌̃; ) LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EC4 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EC4 }};
        std::array<char32_t, 3> const c3 = {{ 0x0045, 0x0302, 0x0303 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EC4 }};
        std::array<char32_t, 3> const c5 = {{ 0x0045, 0x0302, 0x0303 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_056)
{
    // 1EC5;1EC5;0065 0302 0303;1EC5;0065 0302 0303; 
    // (ễ; ễ; e◌̂◌̃; ễ; e◌̂◌̃; ) LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EC5 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EC5 }};
        std::array<char32_t, 3> const c3 = {{ 0x0065, 0x0302, 0x0303 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EC5 }};
        std::array<char32_t, 3> const c5 = {{ 0x0065, 0x0302, 0x0303 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_057)
{
    // 1EC6;1EC6;0045 0323 0302;1EC6;0045 0323 0302; 
    // (Ệ; Ệ; E◌̣◌̂; Ệ; E◌̣◌̂; ) LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EC6 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EC6 }};
        std::array<char32_t, 3> const c3 = {{ 0x0045, 0x0323, 0x0302 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EC6 }};
        std::array<char32_t, 3> const c5 = {{ 0x0045, 0x0323, 0x0302 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_058)
{
    // 1EC7;1EC7;0065 0323 0302;1EC7;0065 0323 0302; 
    // (ệ; ệ; e◌̣◌̂; ệ; e◌̣◌̂; ) LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EC7 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EC7 }};
        std::array<char32_t, 3> const c3 = {{ 0x0065, 0x0323, 0x0302 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EC7 }};
        std::array<char32_t, 3> const c5 = {{ 0x0065, 0x0323, 0x0302 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_059)
{
    // 1EC8;1EC8;0049 0309;1EC8;0049 0309; 
    // (Ỉ; Ỉ; I◌̉; Ỉ; I◌̉; ) LATIN CAPITAL LETTER I WITH HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EC8 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EC8 }};
        std::array<char32_t, 2> const c3 = {{ 0x0049, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EC8 }};
        std::array<char32_t, 2> const c5 = {{ 0x0049, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_060)
{
    // 1EC9;1EC9;0069 0309;1EC9;0069 0309; 
    // (ỉ; ỉ; i◌̉; ỉ; i◌̉; ) LATIN SMALL LETTER I WITH HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EC9 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EC9 }};
        std::array<char32_t, 2> const c3 = {{ 0x0069, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EC9 }};
        std::array<char32_t, 2> const c5 = {{ 0x0069, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_061)
{
    // 1ECA;1ECA;0049 0323;1ECA;0049 0323; 
    // (Ị; Ị; I◌̣; Ị; I◌̣; ) LATIN CAPITAL LETTER I WITH DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1ECA }};
        std::array<char32_t, 1> const c2 = {{ 0x1ECA }};
        std::array<char32_t, 2> const c3 = {{ 0x0049, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1ECA }};
        std::array<char32_t, 2> const c5 = {{ 0x0049, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_062)
{
    // 1ECB;1ECB;0069 0323;1ECB;0069 0323; 
    // (ị; ị; i◌̣; ị; i◌̣; ) LATIN SMALL LETTER I WITH DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1ECB }};
        std::array<char32_t, 1> const c2 = {{ 0x1ECB }};
        std::array<char32_t, 2> const c3 = {{ 0x0069, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1ECB }};
        std::array<char32_t, 2> const c5 = {{ 0x0069, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_063)
{
    // 1ECC;1ECC;004F 0323;1ECC;004F 0323; 
    // (Ọ; Ọ; O◌̣; Ọ; O◌̣; ) LATIN CAPITAL LETTER O WITH DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1ECC }};
        std::array<char32_t, 1> const c2 = {{ 0x1ECC }};
        std::array<char32_t, 2> const c3 = {{ 0x004F, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1ECC }};
        std::array<char32_t, 2> const c5 = {{ 0x004F, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_064)
{
    // 1ECD;1ECD;006F 0323;1ECD;006F 0323; 
    // (ọ; ọ; o◌̣; ọ; o◌̣; ) LATIN SMALL LETTER O WITH DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1ECD }};
        std::array<char32_t, 1> const c2 = {{ 0x1ECD }};
        std::array<char32_t, 2> const c3 = {{ 0x006F, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1ECD }};
        std::array<char32_t, 2> const c5 = {{ 0x006F, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_065)
{
    // 1ECE;1ECE;004F 0309;1ECE;004F 0309; 
    // (Ỏ; Ỏ; O◌̉; Ỏ; O◌̉; ) LATIN CAPITAL LETTER O WITH HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1ECE }};
        std::array<char32_t, 1> const c2 = {{ 0x1ECE }};
        std::array<char32_t, 2> const c3 = {{ 0x004F, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1ECE }};
        std::array<char32_t, 2> const c5 = {{ 0x004F, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_066)
{
    // 1ECF;1ECF;006F 0309;1ECF;006F 0309; 
    // (ỏ; ỏ; o◌̉; ỏ; o◌̉; ) LATIN SMALL LETTER O WITH HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1ECF }};
        std::array<char32_t, 1> const c2 = {{ 0x1ECF }};
        std::array<char32_t, 2> const c3 = {{ 0x006F, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1ECF }};
        std::array<char32_t, 2> const c5 = {{ 0x006F, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_067)
{
    // 1ED0;1ED0;004F 0302 0301;1ED0;004F 0302 0301; 
    // (Ố; Ố; O◌̂◌́; Ố; O◌̂◌́; ) LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1ED0 }};
        std::array<char32_t, 1> const c2 = {{ 0x1ED0 }};
        std::array<char32_t, 3> const c3 = {{ 0x004F, 0x0302, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1ED0 }};
        std::array<char32_t, 3> const c5 = {{ 0x004F, 0x0302, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_068)
{
    // 1ED1;1ED1;006F 0302 0301;1ED1;006F 0302 0301; 
    // (ố; ố; o◌̂◌́; ố; o◌̂◌́; ) LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1ED1 }};
        std::array<char32_t, 1> const c2 = {{ 0x1ED1 }};
        std::array<char32_t, 3> const c3 = {{ 0x006F, 0x0302, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1ED1 }};
        std::array<char32_t, 3> const c5 = {{ 0x006F, 0x0302, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_069)
{
    // 1ED2;1ED2;004F 0302 0300;1ED2;004F 0302 0300; 
    // (Ồ; Ồ; O◌̂◌̀; Ồ; O◌̂◌̀; ) LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1ED2 }};
        std::array<char32_t, 1> const c2 = {{ 0x1ED2 }};
        std::array<char32_t, 3> const c3 = {{ 0x004F, 0x0302, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1ED2 }};
        std::array<char32_t, 3> const c5 = {{ 0x004F, 0x0302, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_070)
{
    // 1ED3;1ED3;006F 0302 0300;1ED3;006F 0302 0300; 
    // (ồ; ồ; o◌̂◌̀; ồ; o◌̂◌̀; ) LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1ED3 }};
        std::array<char32_t, 1> const c2 = {{ 0x1ED3 }};
        std::array<char32_t, 3> const c3 = {{ 0x006F, 0x0302, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1ED3 }};
        std::array<char32_t, 3> const c5 = {{ 0x006F, 0x0302, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_071)
{
    // 1ED4;1ED4;004F 0302 0309;1ED4;004F 0302 0309; 
    // (Ổ; Ổ; O◌̂◌̉; Ổ; O◌̂◌̉; ) LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1ED4 }};
        std::array<char32_t, 1> const c2 = {{ 0x1ED4 }};
        std::array<char32_t, 3> const c3 = {{ 0x004F, 0x0302, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1ED4 }};
        std::array<char32_t, 3> const c5 = {{ 0x004F, 0x0302, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_072)
{
    // 1ED5;1ED5;006F 0302 0309;1ED5;006F 0302 0309; 
    // (ổ; ổ; o◌̂◌̉; ổ; o◌̂◌̉; ) LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1ED5 }};
        std::array<char32_t, 1> const c2 = {{ 0x1ED5 }};
        std::array<char32_t, 3> const c3 = {{ 0x006F, 0x0302, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1ED5 }};
        std::array<char32_t, 3> const c5 = {{ 0x006F, 0x0302, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_073)
{
    // 1ED6;1ED6;004F 0302 0303;1ED6;004F 0302 0303; 
    // (Ỗ; Ỗ; O◌̂◌̃; Ỗ; O◌̂◌̃; ) LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1ED6 }};
        std::array<char32_t, 1> const c2 = {{ 0x1ED6 }};
        std::array<char32_t, 3> const c3 = {{ 0x004F, 0x0302, 0x0303 }};
        std::array<char32_t, 1> const c4 = {{ 0x1ED6 }};
        std::array<char32_t, 3> const c5 = {{ 0x004F, 0x0302, 0x0303 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_074)
{
    // 1ED7;1ED7;006F 0302 0303;1ED7;006F 0302 0303; 
    // (ỗ; ỗ; o◌̂◌̃; ỗ; o◌̂◌̃; ) LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1ED7 }};
        std::array<char32_t, 1> const c2 = {{ 0x1ED7 }};
        std::array<char32_t, 3> const c3 = {{ 0x006F, 0x0302, 0x0303 }};
        std::array<char32_t, 1> const c4 = {{ 0x1ED7 }};
        std::array<char32_t, 3> const c5 = {{ 0x006F, 0x0302, 0x0303 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_075)
{
    // 1ED8;1ED8;004F 0323 0302;1ED8;004F 0323 0302; 
    // (Ộ; Ộ; O◌̣◌̂; Ộ; O◌̣◌̂; ) LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1ED8 }};
        std::array<char32_t, 1> const c2 = {{ 0x1ED8 }};
        std::array<char32_t, 3> const c3 = {{ 0x004F, 0x0323, 0x0302 }};
        std::array<char32_t, 1> const c4 = {{ 0x1ED8 }};
        std::array<char32_t, 3> const c5 = {{ 0x004F, 0x0323, 0x0302 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_076)
{
    // 1ED9;1ED9;006F 0323 0302;1ED9;006F 0323 0302; 
    // (ộ; ộ; o◌̣◌̂; ộ; o◌̣◌̂; ) LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1ED9 }};
        std::array<char32_t, 1> const c2 = {{ 0x1ED9 }};
        std::array<char32_t, 3> const c3 = {{ 0x006F, 0x0323, 0x0302 }};
        std::array<char32_t, 1> const c4 = {{ 0x1ED9 }};
        std::array<char32_t, 3> const c5 = {{ 0x006F, 0x0323, 0x0302 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_077)
{
    // 1EDA;1EDA;004F 031B 0301;1EDA;004F 031B 0301; 
    // (Ớ; Ớ; O◌̛◌́; Ớ; O◌̛◌́; ) LATIN CAPITAL LETTER O WITH HORN AND ACUTE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EDA }};
        std::array<char32_t, 1> const c2 = {{ 0x1EDA }};
        std::array<char32_t, 3> const c3 = {{ 0x004F, 0x031B, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EDA }};
        std::array<char32_t, 3> const c5 = {{ 0x004F, 0x031B, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_078)
{
    // 1EDB;1EDB;006F 031B 0301;1EDB;006F 031B 0301; 
    // (ớ; ớ; o◌̛◌́; ớ; o◌̛◌́; ) LATIN SMALL LETTER O WITH HORN AND ACUTE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EDB }};
        std::array<char32_t, 1> const c2 = {{ 0x1EDB }};
        std::array<char32_t, 3> const c3 = {{ 0x006F, 0x031B, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EDB }};
        std::array<char32_t, 3> const c5 = {{ 0x006F, 0x031B, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_079)
{
    // 1EDC;1EDC;004F 031B 0300;1EDC;004F 031B 0300; 
    // (Ờ; Ờ; O◌̛◌̀; Ờ; O◌̛◌̀; ) LATIN CAPITAL LETTER O WITH HORN AND GRAVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EDC }};
        std::array<char32_t, 1> const c2 = {{ 0x1EDC }};
        std::array<char32_t, 3> const c3 = {{ 0x004F, 0x031B, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EDC }};
        std::array<char32_t, 3> const c5 = {{ 0x004F, 0x031B, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_080)
{
    // 1EDD;1EDD;006F 031B 0300;1EDD;006F 031B 0300; 
    // (ờ; ờ; o◌̛◌̀; ờ; o◌̛◌̀; ) LATIN SMALL LETTER O WITH HORN AND GRAVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EDD }};
        std::array<char32_t, 1> const c2 = {{ 0x1EDD }};
        std::array<char32_t, 3> const c3 = {{ 0x006F, 0x031B, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EDD }};
        std::array<char32_t, 3> const c5 = {{ 0x006F, 0x031B, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_081)
{
    // 1EDE;1EDE;004F 031B 0309;1EDE;004F 031B 0309; 
    // (Ở; Ở; O◌̛◌̉; Ở; O◌̛◌̉; ) LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EDE }};
        std::array<char32_t, 1> const c2 = {{ 0x1EDE }};
        std::array<char32_t, 3> const c3 = {{ 0x004F, 0x031B, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EDE }};
        std::array<char32_t, 3> const c5 = {{ 0x004F, 0x031B, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_082)
{
    // 1EDF;1EDF;006F 031B 0309;1EDF;006F 031B 0309; 
    // (ở; ở; o◌̛◌̉; ở; o◌̛◌̉; ) LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EDF }};
        std::array<char32_t, 1> const c2 = {{ 0x1EDF }};
        std::array<char32_t, 3> const c3 = {{ 0x006F, 0x031B, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EDF }};
        std::array<char32_t, 3> const c5 = {{ 0x006F, 0x031B, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_083)
{
    // 1EE0;1EE0;004F 031B 0303;1EE0;004F 031B 0303; 
    // (Ỡ; Ỡ; O◌̛◌̃; Ỡ; O◌̛◌̃; ) LATIN CAPITAL LETTER O WITH HORN AND TILDE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EE0 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EE0 }};
        std::array<char32_t, 3> const c3 = {{ 0x004F, 0x031B, 0x0303 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EE0 }};
        std::array<char32_t, 3> const c5 = {{ 0x004F, 0x031B, 0x0303 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_084)
{
    // 1EE1;1EE1;006F 031B 0303;1EE1;006F 031B 0303; 
    // (ỡ; ỡ; o◌̛◌̃; ỡ; o◌̛◌̃; ) LATIN SMALL LETTER O WITH HORN AND TILDE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EE1 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EE1 }};
        std::array<char32_t, 3> const c3 = {{ 0x006F, 0x031B, 0x0303 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EE1 }};
        std::array<char32_t, 3> const c5 = {{ 0x006F, 0x031B, 0x0303 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_085)
{
    // 1EE2;1EE2;004F 031B 0323;1EE2;004F 031B 0323; 
    // (Ợ; Ợ; O◌̛◌̣; Ợ; O◌̛◌̣; ) LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EE2 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EE2 }};
        std::array<char32_t, 3> const c3 = {{ 0x004F, 0x031B, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EE2 }};
        std::array<char32_t, 3> const c5 = {{ 0x004F, 0x031B, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_086)
{
    // 1EE3;1EE3;006F 031B 0323;1EE3;006F 031B 0323; 
    // (ợ; ợ; o◌̛◌̣; ợ; o◌̛◌̣; ) LATIN SMALL LETTER O WITH HORN AND DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EE3 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EE3 }};
        std::array<char32_t, 3> const c3 = {{ 0x006F, 0x031B, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EE3 }};
        std::array<char32_t, 3> const c5 = {{ 0x006F, 0x031B, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_087)
{
    // 1EE4;1EE4;0055 0323;1EE4;0055 0323; 
    // (Ụ; Ụ; U◌̣; Ụ; U◌̣; ) LATIN CAPITAL LETTER U WITH DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EE4 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EE4 }};
        std::array<char32_t, 2> const c3 = {{ 0x0055, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EE4 }};
        std::array<char32_t, 2> const c5 = {{ 0x0055, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_088)
{
    // 1EE5;1EE5;0075 0323;1EE5;0075 0323; 
    // (ụ; ụ; u◌̣; ụ; u◌̣; ) LATIN SMALL LETTER U WITH DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EE5 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EE5 }};
        std::array<char32_t, 2> const c3 = {{ 0x0075, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EE5 }};
        std::array<char32_t, 2> const c5 = {{ 0x0075, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_089)
{
    // 1EE6;1EE6;0055 0309;1EE6;0055 0309; 
    // (Ủ; Ủ; U◌̉; Ủ; U◌̉; ) LATIN CAPITAL LETTER U WITH HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EE6 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EE6 }};
        std::array<char32_t, 2> const c3 = {{ 0x0055, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EE6 }};
        std::array<char32_t, 2> const c5 = {{ 0x0055, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_090)
{
    // 1EE7;1EE7;0075 0309;1EE7;0075 0309; 
    // (ủ; ủ; u◌̉; ủ; u◌̉; ) LATIN SMALL LETTER U WITH HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EE7 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EE7 }};
        std::array<char32_t, 2> const c3 = {{ 0x0075, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EE7 }};
        std::array<char32_t, 2> const c5 = {{ 0x0075, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_091)
{
    // 1EE8;1EE8;0055 031B 0301;1EE8;0055 031B 0301; 
    // (Ứ; Ứ; U◌̛◌́; Ứ; U◌̛◌́; ) LATIN CAPITAL LETTER U WITH HORN AND ACUTE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EE8 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EE8 }};
        std::array<char32_t, 3> const c3 = {{ 0x0055, 0x031B, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EE8 }};
        std::array<char32_t, 3> const c5 = {{ 0x0055, 0x031B, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_092)
{
    // 1EE9;1EE9;0075 031B 0301;1EE9;0075 031B 0301; 
    // (ứ; ứ; u◌̛◌́; ứ; u◌̛◌́; ) LATIN SMALL LETTER U WITH HORN AND ACUTE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EE9 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EE9 }};
        std::array<char32_t, 3> const c3 = {{ 0x0075, 0x031B, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EE9 }};
        std::array<char32_t, 3> const c5 = {{ 0x0075, 0x031B, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_093)
{
    // 1EEA;1EEA;0055 031B 0300;1EEA;0055 031B 0300; 
    // (Ừ; Ừ; U◌̛◌̀; Ừ; U◌̛◌̀; ) LATIN CAPITAL LETTER U WITH HORN AND GRAVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EEA }};
        std::array<char32_t, 1> const c2 = {{ 0x1EEA }};
        std::array<char32_t, 3> const c3 = {{ 0x0055, 0x031B, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EEA }};
        std::array<char32_t, 3> const c5 = {{ 0x0055, 0x031B, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_094)
{
    // 1EEB;1EEB;0075 031B 0300;1EEB;0075 031B 0300; 
    // (ừ; ừ; u◌̛◌̀; ừ; u◌̛◌̀; ) LATIN SMALL LETTER U WITH HORN AND GRAVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EEB }};
        std::array<char32_t, 1> const c2 = {{ 0x1EEB }};
        std::array<char32_t, 3> const c3 = {{ 0x0075, 0x031B, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EEB }};
        std::array<char32_t, 3> const c5 = {{ 0x0075, 0x031B, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_095)
{
    // 1EEC;1EEC;0055 031B 0309;1EEC;0055 031B 0309; 
    // (Ử; Ử; U◌̛◌̉; Ử; U◌̛◌̉; ) LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EEC }};
        std::array<char32_t, 1> const c2 = {{ 0x1EEC }};
        std::array<char32_t, 3> const c3 = {{ 0x0055, 0x031B, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EEC }};
        std::array<char32_t, 3> const c5 = {{ 0x0055, 0x031B, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_096)
{
    // 1EED;1EED;0075 031B 0309;1EED;0075 031B 0309; 
    // (ử; ử; u◌̛◌̉; ử; u◌̛◌̉; ) LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EED }};
        std::array<char32_t, 1> const c2 = {{ 0x1EED }};
        std::array<char32_t, 3> const c3 = {{ 0x0075, 0x031B, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EED }};
        std::array<char32_t, 3> const c5 = {{ 0x0075, 0x031B, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_097)
{
    // 1EEE;1EEE;0055 031B 0303;1EEE;0055 031B 0303; 
    // (Ữ; Ữ; U◌̛◌̃; Ữ; U◌̛◌̃; ) LATIN CAPITAL LETTER U WITH HORN AND TILDE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EEE }};
        std::array<char32_t, 1> const c2 = {{ 0x1EEE }};
        std::array<char32_t, 3> const c3 = {{ 0x0055, 0x031B, 0x0303 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EEE }};
        std::array<char32_t, 3> const c5 = {{ 0x0055, 0x031B, 0x0303 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_098)
{
    // 1EEF;1EEF;0075 031B 0303;1EEF;0075 031B 0303; 
    // (ữ; ữ; u◌̛◌̃; ữ; u◌̛◌̃; ) LATIN SMALL LETTER U WITH HORN AND TILDE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EEF }};
        std::array<char32_t, 1> const c2 = {{ 0x1EEF }};
        std::array<char32_t, 3> const c3 = {{ 0x0075, 0x031B, 0x0303 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EEF }};
        std::array<char32_t, 3> const c5 = {{ 0x0075, 0x031B, 0x0303 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_099)
{
    // 1EF0;1EF0;0055 031B 0323;1EF0;0055 031B 0323; 
    // (Ự; Ự; U◌̛◌̣; Ự; U◌̛◌̣; ) LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EF0 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EF0 }};
        std::array<char32_t, 3> const c3 = {{ 0x0055, 0x031B, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EF0 }};
        std::array<char32_t, 3> const c5 = {{ 0x0055, 0x031B, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_100)
{
    // 1EF1;1EF1;0075 031B 0323;1EF1;0075 031B 0323; 
    // (ự; ự; u◌̛◌̣; ự; u◌̛◌̣; ) LATIN SMALL LETTER U WITH HORN AND DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EF1 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EF1 }};
        std::array<char32_t, 3> const c3 = {{ 0x0075, 0x031B, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EF1 }};
        std::array<char32_t, 3> const c5 = {{ 0x0075, 0x031B, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_101)
{
    // 1EF2;1EF2;0059 0300;1EF2;0059 0300; 
    // (Ỳ; Ỳ; Y◌̀; Ỳ; Y◌̀; ) LATIN CAPITAL LETTER Y WITH GRAVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EF2 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EF2 }};
        std::array<char32_t, 2> const c3 = {{ 0x0059, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EF2 }};
        std::array<char32_t, 2> const c5 = {{ 0x0059, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_102)
{
    // 1EF3;1EF3;0079 0300;1EF3;0079 0300; 
    // (ỳ; ỳ; y◌̀; ỳ; y◌̀; ) LATIN SMALL LETTER Y WITH GRAVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EF3 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EF3 }};
        std::array<char32_t, 2> const c3 = {{ 0x0079, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EF3 }};
        std::array<char32_t, 2> const c5 = {{ 0x0079, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_103)
{
    // 1EF4;1EF4;0059 0323;1EF4;0059 0323; 
    // (Ỵ; Ỵ; Y◌̣; Ỵ; Y◌̣; ) LATIN CAPITAL LETTER Y WITH DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EF4 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EF4 }};
        std::array<char32_t, 2> const c3 = {{ 0x0059, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EF4 }};
        std::array<char32_t, 2> const c5 = {{ 0x0059, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_104)
{
    // 1EF5;1EF5;0079 0323;1EF5;0079 0323; 
    // (ỵ; ỵ; y◌̣; ỵ; y◌̣; ) LATIN SMALL LETTER Y WITH DOT BELOW
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EF5 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EF5 }};
        std::array<char32_t, 2> const c3 = {{ 0x0079, 0x0323 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EF5 }};
        std::array<char32_t, 2> const c5 = {{ 0x0079, 0x0323 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_105)
{
    // 1EF6;1EF6;0059 0309;1EF6;0059 0309; 
    // (Ỷ; Ỷ; Y◌̉; Ỷ; Y◌̉; ) LATIN CAPITAL LETTER Y WITH HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EF6 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EF6 }};
        std::array<char32_t, 2> const c3 = {{ 0x0059, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EF6 }};
        std::array<char32_t, 2> const c5 = {{ 0x0059, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_106)
{
    // 1EF7;1EF7;0079 0309;1EF7;0079 0309; 
    // (ỷ; ỷ; y◌̉; ỷ; y◌̉; ) LATIN SMALL LETTER Y WITH HOOK ABOVE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EF7 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EF7 }};
        std::array<char32_t, 2> const c3 = {{ 0x0079, 0x0309 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EF7 }};
        std::array<char32_t, 2> const c5 = {{ 0x0079, 0x0309 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_107)
{
    // 1EF8;1EF8;0059 0303;1EF8;0059 0303; 
    // (Ỹ; Ỹ; Y◌̃; Ỹ; Y◌̃; ) LATIN CAPITAL LETTER Y WITH TILDE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EF8 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EF8 }};
        std::array<char32_t, 2> const c3 = {{ 0x0059, 0x0303 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EF8 }};
        std::array<char32_t, 2> const c5 = {{ 0x0059, 0x0303 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_108)
{
    // 1EF9;1EF9;0079 0303;1EF9;0079 0303; 
    // (ỹ; ỹ; y◌̃; ỹ; y◌̃; ) LATIN SMALL LETTER Y WITH TILDE
    {
        std::array<char32_t, 1> const c1 = {{ 0x1EF9 }};
        std::array<char32_t, 1> const c2 = {{ 0x1EF9 }};
        std::array<char32_t, 2> const c3 = {{ 0x0079, 0x0303 }};
        std::array<char32_t, 1> const c4 = {{ 0x1EF9 }};
        std::array<char32_t, 2> const c5 = {{ 0x0079, 0x0303 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_109)
{
    // 1F00;1F00;03B1 0313;1F00;03B1 0313; 
    // (ἀ; ἀ; α◌̓; ἀ; α◌̓; ) GREEK SMALL LETTER ALPHA WITH PSILI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F00 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F00 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B1, 0x0313 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F00 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B1, 0x0313 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_110)
{
    // 1F01;1F01;03B1 0314;1F01;03B1 0314; 
    // (ἁ; ἁ; α◌̔; ἁ; α◌̔; ) GREEK SMALL LETTER ALPHA WITH DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F01 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F01 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B1, 0x0314 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F01 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B1, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_111)
{
    // 1F02;1F02;03B1 0313 0300;1F02;03B1 0313 0300; 
    // (ἂ; ἂ; α◌̓◌̀; ἂ; α◌̓◌̀; ) GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F02 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F02 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B1, 0x0313, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F02 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B1, 0x0313, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_112)
{
    // 1F03;1F03;03B1 0314 0300;1F03;03B1 0314 0300; 
    // (ἃ; ἃ; α◌̔◌̀; ἃ; α◌̔◌̀; ) GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F03 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F03 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B1, 0x0314, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F03 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B1, 0x0314, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_113)
{
    // 1F04;1F04;03B1 0313 0301;1F04;03B1 0313 0301; 
    // (ἄ; ἄ; α◌̓◌́; ἄ; α◌̓◌́; ) GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F04 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F04 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B1, 0x0313, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F04 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B1, 0x0313, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_114)
{
    // 1F05;1F05;03B1 0314 0301;1F05;03B1 0314 0301; 
    // (ἅ; ἅ; α◌̔◌́; ἅ; α◌̔◌́; ) GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F05 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F05 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B1, 0x0314, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F05 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B1, 0x0314, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_115)
{
    // 1F06;1F06;03B1 0313 0342;1F06;03B1 0313 0342; 
    // (ἆ; ἆ; α◌̓◌͂; ἆ; α◌̓◌͂; ) GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F06 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F06 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B1, 0x0313, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F06 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B1, 0x0313, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_116)
{
    // 1F07;1F07;03B1 0314 0342;1F07;03B1 0314 0342; 
    // (ἇ; ἇ; α◌̔◌͂; ἇ; α◌̔◌͂; ) GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F07 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F07 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B1, 0x0314, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F07 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B1, 0x0314, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_117)
{
    // 1F08;1F08;0391 0313;1F08;0391 0313; 
    // (Ἀ; Ἀ; Α◌̓; Ἀ; Α◌̓; ) GREEK CAPITAL LETTER ALPHA WITH PSILI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F08 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F08 }};
        std::array<char32_t, 2> const c3 = {{ 0x0391, 0x0313 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F08 }};
        std::array<char32_t, 2> const c5 = {{ 0x0391, 0x0313 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_118)
{
    // 1F09;1F09;0391 0314;1F09;0391 0314; 
    // (Ἁ; Ἁ; Α◌̔; Ἁ; Α◌̔; ) GREEK CAPITAL LETTER ALPHA WITH DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F09 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F09 }};
        std::array<char32_t, 2> const c3 = {{ 0x0391, 0x0314 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F09 }};
        std::array<char32_t, 2> const c5 = {{ 0x0391, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_119)
{
    // 1F0A;1F0A;0391 0313 0300;1F0A;0391 0313 0300; 
    // (Ἂ; Ἂ; Α◌̓◌̀; Ἂ; Α◌̓◌̀; ) GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F0A }};
        std::array<char32_t, 1> const c2 = {{ 0x1F0A }};
        std::array<char32_t, 3> const c3 = {{ 0x0391, 0x0313, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F0A }};
        std::array<char32_t, 3> const c5 = {{ 0x0391, 0x0313, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_120)
{
    // 1F0B;1F0B;0391 0314 0300;1F0B;0391 0314 0300; 
    // (Ἃ; Ἃ; Α◌̔◌̀; Ἃ; Α◌̔◌̀; ) GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F0B }};
        std::array<char32_t, 1> const c2 = {{ 0x1F0B }};
        std::array<char32_t, 3> const c3 = {{ 0x0391, 0x0314, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F0B }};
        std::array<char32_t, 3> const c5 = {{ 0x0391, 0x0314, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_121)
{
    // 1F0C;1F0C;0391 0313 0301;1F0C;0391 0313 0301; 
    // (Ἄ; Ἄ; Α◌̓◌́; Ἄ; Α◌̓◌́; ) GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F0C }};
        std::array<char32_t, 1> const c2 = {{ 0x1F0C }};
        std::array<char32_t, 3> const c3 = {{ 0x0391, 0x0313, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F0C }};
        std::array<char32_t, 3> const c5 = {{ 0x0391, 0x0313, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_122)
{
    // 1F0D;1F0D;0391 0314 0301;1F0D;0391 0314 0301; 
    // (Ἅ; Ἅ; Α◌̔◌́; Ἅ; Α◌̔◌́; ) GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F0D }};
        std::array<char32_t, 1> const c2 = {{ 0x1F0D }};
        std::array<char32_t, 3> const c3 = {{ 0x0391, 0x0314, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F0D }};
        std::array<char32_t, 3> const c5 = {{ 0x0391, 0x0314, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_123)
{
    // 1F0E;1F0E;0391 0313 0342;1F0E;0391 0313 0342; 
    // (Ἆ; Ἆ; Α◌̓◌͂; Ἆ; Α◌̓◌͂; ) GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F0E }};
        std::array<char32_t, 1> const c2 = {{ 0x1F0E }};
        std::array<char32_t, 3> const c3 = {{ 0x0391, 0x0313, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F0E }};
        std::array<char32_t, 3> const c5 = {{ 0x0391, 0x0313, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_124)
{
    // 1F0F;1F0F;0391 0314 0342;1F0F;0391 0314 0342; 
    // (Ἇ; Ἇ; Α◌̔◌͂; Ἇ; Α◌̔◌͂; ) GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F0F }};
        std::array<char32_t, 1> const c2 = {{ 0x1F0F }};
        std::array<char32_t, 3> const c3 = {{ 0x0391, 0x0314, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F0F }};
        std::array<char32_t, 3> const c5 = {{ 0x0391, 0x0314, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_125)
{
    // 1F10;1F10;03B5 0313;1F10;03B5 0313; 
    // (ἐ; ἐ; ε◌̓; ἐ; ε◌̓; ) GREEK SMALL LETTER EPSILON WITH PSILI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F10 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F10 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B5, 0x0313 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F10 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B5, 0x0313 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_126)
{
    // 1F11;1F11;03B5 0314;1F11;03B5 0314; 
    // (ἑ; ἑ; ε◌̔; ἑ; ε◌̔; ) GREEK SMALL LETTER EPSILON WITH DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F11 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F11 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B5, 0x0314 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F11 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B5, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_127)
{
    // 1F12;1F12;03B5 0313 0300;1F12;03B5 0313 0300; 
    // (ἒ; ἒ; ε◌̓◌̀; ἒ; ε◌̓◌̀; ) GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F12 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F12 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B5, 0x0313, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F12 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B5, 0x0313, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_128)
{
    // 1F13;1F13;03B5 0314 0300;1F13;03B5 0314 0300; 
    // (ἓ; ἓ; ε◌̔◌̀; ἓ; ε◌̔◌̀; ) GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F13 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F13 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B5, 0x0314, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F13 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B5, 0x0314, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_129)
{
    // 1F14;1F14;03B5 0313 0301;1F14;03B5 0313 0301; 
    // (ἔ; ἔ; ε◌̓◌́; ἔ; ε◌̓◌́; ) GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F14 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F14 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B5, 0x0313, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F14 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B5, 0x0313, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_130)
{
    // 1F15;1F15;03B5 0314 0301;1F15;03B5 0314 0301; 
    // (ἕ; ἕ; ε◌̔◌́; ἕ; ε◌̔◌́; ) GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F15 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F15 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B5, 0x0314, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F15 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B5, 0x0314, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_131)
{
    // 1F18;1F18;0395 0313;1F18;0395 0313; 
    // (Ἐ; Ἐ; Ε◌̓; Ἐ; Ε◌̓; ) GREEK CAPITAL LETTER EPSILON WITH PSILI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F18 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F18 }};
        std::array<char32_t, 2> const c3 = {{ 0x0395, 0x0313 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F18 }};
        std::array<char32_t, 2> const c5 = {{ 0x0395, 0x0313 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_132)
{
    // 1F19;1F19;0395 0314;1F19;0395 0314; 
    // (Ἑ; Ἑ; Ε◌̔; Ἑ; Ε◌̔; ) GREEK CAPITAL LETTER EPSILON WITH DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F19 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F19 }};
        std::array<char32_t, 2> const c3 = {{ 0x0395, 0x0314 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F19 }};
        std::array<char32_t, 2> const c5 = {{ 0x0395, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_133)
{
    // 1F1A;1F1A;0395 0313 0300;1F1A;0395 0313 0300; 
    // (Ἒ; Ἒ; Ε◌̓◌̀; Ἒ; Ε◌̓◌̀; ) GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F1A }};
        std::array<char32_t, 1> const c2 = {{ 0x1F1A }};
        std::array<char32_t, 3> const c3 = {{ 0x0395, 0x0313, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F1A }};
        std::array<char32_t, 3> const c5 = {{ 0x0395, 0x0313, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_134)
{
    // 1F1B;1F1B;0395 0314 0300;1F1B;0395 0314 0300; 
    // (Ἓ; Ἓ; Ε◌̔◌̀; Ἓ; Ε◌̔◌̀; ) GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F1B }};
        std::array<char32_t, 1> const c2 = {{ 0x1F1B }};
        std::array<char32_t, 3> const c3 = {{ 0x0395, 0x0314, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F1B }};
        std::array<char32_t, 3> const c5 = {{ 0x0395, 0x0314, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_135)
{
    // 1F1C;1F1C;0395 0313 0301;1F1C;0395 0313 0301; 
    // (Ἔ; Ἔ; Ε◌̓◌́; Ἔ; Ε◌̓◌́; ) GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F1C }};
        std::array<char32_t, 1> const c2 = {{ 0x1F1C }};
        std::array<char32_t, 3> const c3 = {{ 0x0395, 0x0313, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F1C }};
        std::array<char32_t, 3> const c5 = {{ 0x0395, 0x0313, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_136)
{
    // 1F1D;1F1D;0395 0314 0301;1F1D;0395 0314 0301; 
    // (Ἕ; Ἕ; Ε◌̔◌́; Ἕ; Ε◌̔◌́; ) GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F1D }};
        std::array<char32_t, 1> const c2 = {{ 0x1F1D }};
        std::array<char32_t, 3> const c3 = {{ 0x0395, 0x0314, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F1D }};
        std::array<char32_t, 3> const c5 = {{ 0x0395, 0x0314, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_137)
{
    // 1F20;1F20;03B7 0313;1F20;03B7 0313; 
    // (ἠ; ἠ; η◌̓; ἠ; η◌̓; ) GREEK SMALL LETTER ETA WITH PSILI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F20 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F20 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B7, 0x0313 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F20 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B7, 0x0313 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_138)
{
    // 1F21;1F21;03B7 0314;1F21;03B7 0314; 
    // (ἡ; ἡ; η◌̔; ἡ; η◌̔; ) GREEK SMALL LETTER ETA WITH DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F21 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F21 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B7, 0x0314 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F21 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B7, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_139)
{
    // 1F22;1F22;03B7 0313 0300;1F22;03B7 0313 0300; 
    // (ἢ; ἢ; η◌̓◌̀; ἢ; η◌̓◌̀; ) GREEK SMALL LETTER ETA WITH PSILI AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F22 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F22 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B7, 0x0313, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F22 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B7, 0x0313, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_140)
{
    // 1F23;1F23;03B7 0314 0300;1F23;03B7 0314 0300; 
    // (ἣ; ἣ; η◌̔◌̀; ἣ; η◌̔◌̀; ) GREEK SMALL LETTER ETA WITH DASIA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F23 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F23 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B7, 0x0314, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F23 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B7, 0x0314, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_141)
{
    // 1F24;1F24;03B7 0313 0301;1F24;03B7 0313 0301; 
    // (ἤ; ἤ; η◌̓◌́; ἤ; η◌̓◌́; ) GREEK SMALL LETTER ETA WITH PSILI AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F24 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F24 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B7, 0x0313, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F24 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B7, 0x0313, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_142)
{
    // 1F25;1F25;03B7 0314 0301;1F25;03B7 0314 0301; 
    // (ἥ; ἥ; η◌̔◌́; ἥ; η◌̔◌́; ) GREEK SMALL LETTER ETA WITH DASIA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F25 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F25 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B7, 0x0314, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F25 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B7, 0x0314, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_143)
{
    // 1F26;1F26;03B7 0313 0342;1F26;03B7 0313 0342; 
    // (ἦ; ἦ; η◌̓◌͂; ἦ; η◌̓◌͂; ) GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F26 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F26 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B7, 0x0313, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F26 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B7, 0x0313, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_144)
{
    // 1F27;1F27;03B7 0314 0342;1F27;03B7 0314 0342; 
    // (ἧ; ἧ; η◌̔◌͂; ἧ; η◌̔◌͂; ) GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F27 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F27 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B7, 0x0314, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F27 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B7, 0x0314, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_145)
{
    // 1F28;1F28;0397 0313;1F28;0397 0313; 
    // (Ἠ; Ἠ; Η◌̓; Ἠ; Η◌̓; ) GREEK CAPITAL LETTER ETA WITH PSILI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F28 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F28 }};
        std::array<char32_t, 2> const c3 = {{ 0x0397, 0x0313 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F28 }};
        std::array<char32_t, 2> const c5 = {{ 0x0397, 0x0313 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_146)
{
    // 1F29;1F29;0397 0314;1F29;0397 0314; 
    // (Ἡ; Ἡ; Η◌̔; Ἡ; Η◌̔; ) GREEK CAPITAL LETTER ETA WITH DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F29 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F29 }};
        std::array<char32_t, 2> const c3 = {{ 0x0397, 0x0314 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F29 }};
        std::array<char32_t, 2> const c5 = {{ 0x0397, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_147)
{
    // 1F2A;1F2A;0397 0313 0300;1F2A;0397 0313 0300; 
    // (Ἢ; Ἢ; Η◌̓◌̀; Ἢ; Η◌̓◌̀; ) GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F2A }};
        std::array<char32_t, 1> const c2 = {{ 0x1F2A }};
        std::array<char32_t, 3> const c3 = {{ 0x0397, 0x0313, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F2A }};
        std::array<char32_t, 3> const c5 = {{ 0x0397, 0x0313, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_148)
{
    // 1F2B;1F2B;0397 0314 0300;1F2B;0397 0314 0300; 
    // (Ἣ; Ἣ; Η◌̔◌̀; Ἣ; Η◌̔◌̀; ) GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F2B }};
        std::array<char32_t, 1> const c2 = {{ 0x1F2B }};
        std::array<char32_t, 3> const c3 = {{ 0x0397, 0x0314, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F2B }};
        std::array<char32_t, 3> const c5 = {{ 0x0397, 0x0314, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_149)
{
    // 1F2C;1F2C;0397 0313 0301;1F2C;0397 0313 0301; 
    // (Ἤ; Ἤ; Η◌̓◌́; Ἤ; Η◌̓◌́; ) GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F2C }};
        std::array<char32_t, 1> const c2 = {{ 0x1F2C }};
        std::array<char32_t, 3> const c3 = {{ 0x0397, 0x0313, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F2C }};
        std::array<char32_t, 3> const c5 = {{ 0x0397, 0x0313, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_150)
{
    // 1F2D;1F2D;0397 0314 0301;1F2D;0397 0314 0301; 
    // (Ἥ; Ἥ; Η◌̔◌́; Ἥ; Η◌̔◌́; ) GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F2D }};
        std::array<char32_t, 1> const c2 = {{ 0x1F2D }};
        std::array<char32_t, 3> const c3 = {{ 0x0397, 0x0314, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F2D }};
        std::array<char32_t, 3> const c5 = {{ 0x0397, 0x0314, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_151)
{
    // 1F2E;1F2E;0397 0313 0342;1F2E;0397 0313 0342; 
    // (Ἦ; Ἦ; Η◌̓◌͂; Ἦ; Η◌̓◌͂; ) GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F2E }};
        std::array<char32_t, 1> const c2 = {{ 0x1F2E }};
        std::array<char32_t, 3> const c3 = {{ 0x0397, 0x0313, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F2E }};
        std::array<char32_t, 3> const c5 = {{ 0x0397, 0x0313, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_152)
{
    // 1F2F;1F2F;0397 0314 0342;1F2F;0397 0314 0342; 
    // (Ἧ; Ἧ; Η◌̔◌͂; Ἧ; Η◌̔◌͂; ) GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F2F }};
        std::array<char32_t, 1> const c2 = {{ 0x1F2F }};
        std::array<char32_t, 3> const c3 = {{ 0x0397, 0x0314, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F2F }};
        std::array<char32_t, 3> const c5 = {{ 0x0397, 0x0314, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_153)
{
    // 1F30;1F30;03B9 0313;1F30;03B9 0313; 
    // (ἰ; ἰ; ι◌̓; ἰ; ι◌̓; ) GREEK SMALL LETTER IOTA WITH PSILI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F30 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F30 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B9, 0x0313 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F30 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B9, 0x0313 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_154)
{
    // 1F31;1F31;03B9 0314;1F31;03B9 0314; 
    // (ἱ; ἱ; ι◌̔; ἱ; ι◌̔; ) GREEK SMALL LETTER IOTA WITH DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F31 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F31 }};
        std::array<char32_t, 2> const c3 = {{ 0x03B9, 0x0314 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F31 }};
        std::array<char32_t, 2> const c5 = {{ 0x03B9, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_155)
{
    // 1F32;1F32;03B9 0313 0300;1F32;03B9 0313 0300; 
    // (ἲ; ἲ; ι◌̓◌̀; ἲ; ι◌̓◌̀; ) GREEK SMALL LETTER IOTA WITH PSILI AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F32 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F32 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B9, 0x0313, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F32 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B9, 0x0313, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_156)
{
    // 1F33;1F33;03B9 0314 0300;1F33;03B9 0314 0300; 
    // (ἳ; ἳ; ι◌̔◌̀; ἳ; ι◌̔◌̀; ) GREEK SMALL LETTER IOTA WITH DASIA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F33 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F33 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B9, 0x0314, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F33 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B9, 0x0314, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_157)
{
    // 1F34;1F34;03B9 0313 0301;1F34;03B9 0313 0301; 
    // (ἴ; ἴ; ι◌̓◌́; ἴ; ι◌̓◌́; ) GREEK SMALL LETTER IOTA WITH PSILI AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F34 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F34 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B9, 0x0313, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F34 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B9, 0x0313, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_158)
{
    // 1F35;1F35;03B9 0314 0301;1F35;03B9 0314 0301; 
    // (ἵ; ἵ; ι◌̔◌́; ἵ; ι◌̔◌́; ) GREEK SMALL LETTER IOTA WITH DASIA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F35 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F35 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B9, 0x0314, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F35 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B9, 0x0314, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_159)
{
    // 1F36;1F36;03B9 0313 0342;1F36;03B9 0313 0342; 
    // (ἶ; ἶ; ι◌̓◌͂; ἶ; ι◌̓◌͂; ) GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F36 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F36 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B9, 0x0313, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F36 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B9, 0x0313, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_160)
{
    // 1F37;1F37;03B9 0314 0342;1F37;03B9 0314 0342; 
    // (ἷ; ἷ; ι◌̔◌͂; ἷ; ι◌̔◌͂; ) GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F37 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F37 }};
        std::array<char32_t, 3> const c3 = {{ 0x03B9, 0x0314, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F37 }};
        std::array<char32_t, 3> const c5 = {{ 0x03B9, 0x0314, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_161)
{
    // 1F38;1F38;0399 0313;1F38;0399 0313; 
    // (Ἰ; Ἰ; Ι◌̓; Ἰ; Ι◌̓; ) GREEK CAPITAL LETTER IOTA WITH PSILI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F38 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F38 }};
        std::array<char32_t, 2> const c3 = {{ 0x0399, 0x0313 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F38 }};
        std::array<char32_t, 2> const c5 = {{ 0x0399, 0x0313 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_162)
{
    // 1F39;1F39;0399 0314;1F39;0399 0314; 
    // (Ἱ; Ἱ; Ι◌̔; Ἱ; Ι◌̔; ) GREEK CAPITAL LETTER IOTA WITH DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F39 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F39 }};
        std::array<char32_t, 2> const c3 = {{ 0x0399, 0x0314 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F39 }};
        std::array<char32_t, 2> const c5 = {{ 0x0399, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_163)
{
    // 1F3A;1F3A;0399 0313 0300;1F3A;0399 0313 0300; 
    // (Ἲ; Ἲ; Ι◌̓◌̀; Ἲ; Ι◌̓◌̀; ) GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F3A }};
        std::array<char32_t, 1> const c2 = {{ 0x1F3A }};
        std::array<char32_t, 3> const c3 = {{ 0x0399, 0x0313, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F3A }};
        std::array<char32_t, 3> const c5 = {{ 0x0399, 0x0313, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_164)
{
    // 1F3B;1F3B;0399 0314 0300;1F3B;0399 0314 0300; 
    // (Ἳ; Ἳ; Ι◌̔◌̀; Ἳ; Ι◌̔◌̀; ) GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F3B }};
        std::array<char32_t, 1> const c2 = {{ 0x1F3B }};
        std::array<char32_t, 3> const c3 = {{ 0x0399, 0x0314, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F3B }};
        std::array<char32_t, 3> const c5 = {{ 0x0399, 0x0314, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_165)
{
    // 1F3C;1F3C;0399 0313 0301;1F3C;0399 0313 0301; 
    // (Ἴ; Ἴ; Ι◌̓◌́; Ἴ; Ι◌̓◌́; ) GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F3C }};
        std::array<char32_t, 1> const c2 = {{ 0x1F3C }};
        std::array<char32_t, 3> const c3 = {{ 0x0399, 0x0313, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F3C }};
        std::array<char32_t, 3> const c5 = {{ 0x0399, 0x0313, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_166)
{
    // 1F3D;1F3D;0399 0314 0301;1F3D;0399 0314 0301; 
    // (Ἵ; Ἵ; Ι◌̔◌́; Ἵ; Ι◌̔◌́; ) GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F3D }};
        std::array<char32_t, 1> const c2 = {{ 0x1F3D }};
        std::array<char32_t, 3> const c3 = {{ 0x0399, 0x0314, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F3D }};
        std::array<char32_t, 3> const c5 = {{ 0x0399, 0x0314, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_167)
{
    // 1F3E;1F3E;0399 0313 0342;1F3E;0399 0313 0342; 
    // (Ἶ; Ἶ; Ι◌̓◌͂; Ἶ; Ι◌̓◌͂; ) GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F3E }};
        std::array<char32_t, 1> const c2 = {{ 0x1F3E }};
        std::array<char32_t, 3> const c3 = {{ 0x0399, 0x0313, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F3E }};
        std::array<char32_t, 3> const c5 = {{ 0x0399, 0x0313, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_168)
{
    // 1F3F;1F3F;0399 0314 0342;1F3F;0399 0314 0342; 
    // (Ἷ; Ἷ; Ι◌̔◌͂; Ἷ; Ι◌̔◌͂; ) GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F3F }};
        std::array<char32_t, 1> const c2 = {{ 0x1F3F }};
        std::array<char32_t, 3> const c3 = {{ 0x0399, 0x0314, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F3F }};
        std::array<char32_t, 3> const c5 = {{ 0x0399, 0x0314, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_169)
{
    // 1F40;1F40;03BF 0313;1F40;03BF 0313; 
    // (ὀ; ὀ; ο◌̓; ὀ; ο◌̓; ) GREEK SMALL LETTER OMICRON WITH PSILI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F40 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F40 }};
        std::array<char32_t, 2> const c3 = {{ 0x03BF, 0x0313 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F40 }};
        std::array<char32_t, 2> const c5 = {{ 0x03BF, 0x0313 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_170)
{
    // 1F41;1F41;03BF 0314;1F41;03BF 0314; 
    // (ὁ; ὁ; ο◌̔; ὁ; ο◌̔; ) GREEK SMALL LETTER OMICRON WITH DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F41 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F41 }};
        std::array<char32_t, 2> const c3 = {{ 0x03BF, 0x0314 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F41 }};
        std::array<char32_t, 2> const c5 = {{ 0x03BF, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_171)
{
    // 1F42;1F42;03BF 0313 0300;1F42;03BF 0313 0300; 
    // (ὂ; ὂ; ο◌̓◌̀; ὂ; ο◌̓◌̀; ) GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F42 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F42 }};
        std::array<char32_t, 3> const c3 = {{ 0x03BF, 0x0313, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F42 }};
        std::array<char32_t, 3> const c5 = {{ 0x03BF, 0x0313, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_172)
{
    // 1F43;1F43;03BF 0314 0300;1F43;03BF 0314 0300; 
    // (ὃ; ὃ; ο◌̔◌̀; ὃ; ο◌̔◌̀; ) GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F43 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F43 }};
        std::array<char32_t, 3> const c3 = {{ 0x03BF, 0x0314, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F43 }};
        std::array<char32_t, 3> const c5 = {{ 0x03BF, 0x0314, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_173)
{
    // 1F44;1F44;03BF 0313 0301;1F44;03BF 0313 0301; 
    // (ὄ; ὄ; ο◌̓◌́; ὄ; ο◌̓◌́; ) GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F44 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F44 }};
        std::array<char32_t, 3> const c3 = {{ 0x03BF, 0x0313, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F44 }};
        std::array<char32_t, 3> const c5 = {{ 0x03BF, 0x0313, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_174)
{
    // 1F45;1F45;03BF 0314 0301;1F45;03BF 0314 0301; 
    // (ὅ; ὅ; ο◌̔◌́; ὅ; ο◌̔◌́; ) GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F45 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F45 }};
        std::array<char32_t, 3> const c3 = {{ 0x03BF, 0x0314, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F45 }};
        std::array<char32_t, 3> const c5 = {{ 0x03BF, 0x0314, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_175)
{
    // 1F48;1F48;039F 0313;1F48;039F 0313; 
    // (Ὀ; Ὀ; Ο◌̓; Ὀ; Ο◌̓; ) GREEK CAPITAL LETTER OMICRON WITH PSILI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F48 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F48 }};
        std::array<char32_t, 2> const c3 = {{ 0x039F, 0x0313 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F48 }};
        std::array<char32_t, 2> const c5 = {{ 0x039F, 0x0313 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_176)
{
    // 1F49;1F49;039F 0314;1F49;039F 0314; 
    // (Ὁ; Ὁ; Ο◌̔; Ὁ; Ο◌̔; ) GREEK CAPITAL LETTER OMICRON WITH DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F49 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F49 }};
        std::array<char32_t, 2> const c3 = {{ 0x039F, 0x0314 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F49 }};
        std::array<char32_t, 2> const c5 = {{ 0x039F, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_177)
{
    // 1F4A;1F4A;039F 0313 0300;1F4A;039F 0313 0300; 
    // (Ὂ; Ὂ; Ο◌̓◌̀; Ὂ; Ο◌̓◌̀; ) GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F4A }};
        std::array<char32_t, 1> const c2 = {{ 0x1F4A }};
        std::array<char32_t, 3> const c3 = {{ 0x039F, 0x0313, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F4A }};
        std::array<char32_t, 3> const c5 = {{ 0x039F, 0x0313, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_178)
{
    // 1F4B;1F4B;039F 0314 0300;1F4B;039F 0314 0300; 
    // (Ὃ; Ὃ; Ο◌̔◌̀; Ὃ; Ο◌̔◌̀; ) GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F4B }};
        std::array<char32_t, 1> const c2 = {{ 0x1F4B }};
        std::array<char32_t, 3> const c3 = {{ 0x039F, 0x0314, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F4B }};
        std::array<char32_t, 3> const c5 = {{ 0x039F, 0x0314, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_179)
{
    // 1F4C;1F4C;039F 0313 0301;1F4C;039F 0313 0301; 
    // (Ὄ; Ὄ; Ο◌̓◌́; Ὄ; Ο◌̓◌́; ) GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F4C }};
        std::array<char32_t, 1> const c2 = {{ 0x1F4C }};
        std::array<char32_t, 3> const c3 = {{ 0x039F, 0x0313, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F4C }};
        std::array<char32_t, 3> const c5 = {{ 0x039F, 0x0313, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_180)
{
    // 1F4D;1F4D;039F 0314 0301;1F4D;039F 0314 0301; 
    // (Ὅ; Ὅ; Ο◌̔◌́; Ὅ; Ο◌̔◌́; ) GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F4D }};
        std::array<char32_t, 1> const c2 = {{ 0x1F4D }};
        std::array<char32_t, 3> const c3 = {{ 0x039F, 0x0314, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F4D }};
        std::array<char32_t, 3> const c5 = {{ 0x039F, 0x0314, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_181)
{
    // 1F50;1F50;03C5 0313;1F50;03C5 0313; 
    // (ὐ; ὐ; υ◌̓; ὐ; υ◌̓; ) GREEK SMALL LETTER UPSILON WITH PSILI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F50 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F50 }};
        std::array<char32_t, 2> const c3 = {{ 0x03C5, 0x0313 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F50 }};
        std::array<char32_t, 2> const c5 = {{ 0x03C5, 0x0313 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_182)
{
    // 1F51;1F51;03C5 0314;1F51;03C5 0314; 
    // (ὑ; ὑ; υ◌̔; ὑ; υ◌̔; ) GREEK SMALL LETTER UPSILON WITH DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F51 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F51 }};
        std::array<char32_t, 2> const c3 = {{ 0x03C5, 0x0314 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F51 }};
        std::array<char32_t, 2> const c5 = {{ 0x03C5, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_183)
{
    // 1F52;1F52;03C5 0313 0300;1F52;03C5 0313 0300; 
    // (ὒ; ὒ; υ◌̓◌̀; ὒ; υ◌̓◌̀; ) GREEK SMALL LETTER UPSILON WITH PSILI AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F52 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F52 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C5, 0x0313, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F52 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C5, 0x0313, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_184)
{
    // 1F53;1F53;03C5 0314 0300;1F53;03C5 0314 0300; 
    // (ὓ; ὓ; υ◌̔◌̀; ὓ; υ◌̔◌̀; ) GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F53 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F53 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C5, 0x0314, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F53 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C5, 0x0314, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_185)
{
    // 1F54;1F54;03C5 0313 0301;1F54;03C5 0313 0301; 
    // (ὔ; ὔ; υ◌̓◌́; ὔ; υ◌̓◌́; ) GREEK SMALL LETTER UPSILON WITH PSILI AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F54 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F54 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C5, 0x0313, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F54 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C5, 0x0313, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_186)
{
    // 1F55;1F55;03C5 0314 0301;1F55;03C5 0314 0301; 
    // (ὕ; ὕ; υ◌̔◌́; ὕ; υ◌̔◌́; ) GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F55 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F55 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C5, 0x0314, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F55 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C5, 0x0314, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_187)
{
    // 1F56;1F56;03C5 0313 0342;1F56;03C5 0313 0342; 
    // (ὖ; ὖ; υ◌̓◌͂; ὖ; υ◌̓◌͂; ) GREEK SMALL LETTER UPSILON WITH PSILI AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F56 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F56 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C5, 0x0313, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F56 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C5, 0x0313, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_188)
{
    // 1F57;1F57;03C5 0314 0342;1F57;03C5 0314 0342; 
    // (ὗ; ὗ; υ◌̔◌͂; ὗ; υ◌̔◌͂; ) GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F57 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F57 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C5, 0x0314, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F57 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C5, 0x0314, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_189)
{
    // 1F59;1F59;03A5 0314;1F59;03A5 0314; 
    // (Ὑ; Ὑ; Υ◌̔; Ὑ; Υ◌̔; ) GREEK CAPITAL LETTER UPSILON WITH DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F59 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F59 }};
        std::array<char32_t, 2> const c3 = {{ 0x03A5, 0x0314 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F59 }};
        std::array<char32_t, 2> const c5 = {{ 0x03A5, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_190)
{
    // 1F5B;1F5B;03A5 0314 0300;1F5B;03A5 0314 0300; 
    // (Ὓ; Ὓ; Υ◌̔◌̀; Ὓ; Υ◌̔◌̀; ) GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F5B }};
        std::array<char32_t, 1> const c2 = {{ 0x1F5B }};
        std::array<char32_t, 3> const c3 = {{ 0x03A5, 0x0314, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F5B }};
        std::array<char32_t, 3> const c5 = {{ 0x03A5, 0x0314, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_191)
{
    // 1F5D;1F5D;03A5 0314 0301;1F5D;03A5 0314 0301; 
    // (Ὕ; Ὕ; Υ◌̔◌́; Ὕ; Υ◌̔◌́; ) GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F5D }};
        std::array<char32_t, 1> const c2 = {{ 0x1F5D }};
        std::array<char32_t, 3> const c3 = {{ 0x03A5, 0x0314, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F5D }};
        std::array<char32_t, 3> const c5 = {{ 0x03A5, 0x0314, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_192)
{
    // 1F5F;1F5F;03A5 0314 0342;1F5F;03A5 0314 0342; 
    // (Ὗ; Ὗ; Υ◌̔◌͂; Ὗ; Υ◌̔◌͂; ) GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F5F }};
        std::array<char32_t, 1> const c2 = {{ 0x1F5F }};
        std::array<char32_t, 3> const c3 = {{ 0x03A5, 0x0314, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F5F }};
        std::array<char32_t, 3> const c5 = {{ 0x03A5, 0x0314, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_193)
{
    // 1F60;1F60;03C9 0313;1F60;03C9 0313; 
    // (ὠ; ὠ; ω◌̓; ὠ; ω◌̓; ) GREEK SMALL LETTER OMEGA WITH PSILI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F60 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F60 }};
        std::array<char32_t, 2> const c3 = {{ 0x03C9, 0x0313 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F60 }};
        std::array<char32_t, 2> const c5 = {{ 0x03C9, 0x0313 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_194)
{
    // 1F61;1F61;03C9 0314;1F61;03C9 0314; 
    // (ὡ; ὡ; ω◌̔; ὡ; ω◌̔; ) GREEK SMALL LETTER OMEGA WITH DASIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F61 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F61 }};
        std::array<char32_t, 2> const c3 = {{ 0x03C9, 0x0314 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F61 }};
        std::array<char32_t, 2> const c5 = {{ 0x03C9, 0x0314 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_195)
{
    // 1F62;1F62;03C9 0313 0300;1F62;03C9 0313 0300; 
    // (ὢ; ὢ; ω◌̓◌̀; ὢ; ω◌̓◌̀; ) GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F62 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F62 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C9, 0x0313, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F62 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C9, 0x0313, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_196)
{
    // 1F63;1F63;03C9 0314 0300;1F63;03C9 0314 0300; 
    // (ὣ; ὣ; ω◌̔◌̀; ὣ; ω◌̔◌̀; ) GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F63 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F63 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C9, 0x0314, 0x0300 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F63 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C9, 0x0314, 0x0300 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_197)
{
    // 1F64;1F64;03C9 0313 0301;1F64;03C9 0313 0301; 
    // (ὤ; ὤ; ω◌̓◌́; ὤ; ω◌̓◌́; ) GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F64 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F64 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C9, 0x0313, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F64 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C9, 0x0313, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_198)
{
    // 1F65;1F65;03C9 0314 0301;1F65;03C9 0314 0301; 
    // (ὥ; ὥ; ω◌̔◌́; ὥ; ω◌̔◌́; ) GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F65 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F65 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C9, 0x0314, 0x0301 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F65 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C9, 0x0314, 0x0301 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


TEST(normalization, nfkc_004_199)
{
    // 1F66;1F66;03C9 0313 0342;1F66;03C9 0313 0342; 
    // (ὦ; ὦ; ω◌̓◌͂; ὦ; ω◌̓◌͂; ) GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI
    {
        std::array<char32_t, 1> const c1 = {{ 0x1F66 }};
        std::array<char32_t, 1> const c2 = {{ 0x1F66 }};
        std::array<char32_t, 3> const c3 = {{ 0x03C9, 0x0313, 0x0342 }};
        std::array<char32_t, 1> const c4 = {{ 0x1F66 }};
        std::array<char32_t, 3> const c5 = {{ 0x03C9, 0x0313, 0x0342 }};

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::is_normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::u8string strs[3] = {boost::text::to_u8string(c1.begin(), c1.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c2.begin(), c2.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c3.begin(), c3.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c4.begin(), c4.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

        {
            std::u8string strs[3] = {boost::text::to_u8string(c5.begin(), c5.end())};
            auto v = strs[0] | boost::text::as_nfkc | boost::text::as_utf8;
            for (auto c : v) {
                strs[1] += c;
            }
            for (auto it = v.end(), first = v.begin(); it != first;) {
                --it;
                strs[2] += *it;
            }
            std::reverse(strs[2].begin(), strs[2].end());
            boost::text::normalize<boost::text::nf::kc>(strs[0]);
            for (auto str : strs) {
                auto const r = boost::text::as_utf32(str);
                EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
                auto c4_it = c4.begin();
                int i = 0;
                for (auto x : r) {
                    EXPECT_EQ(x, *c4_it) << "iteration " << i;
                    ++c4_it;
                    ++i;
                }
            }
        }

    }
}


