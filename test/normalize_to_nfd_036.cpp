// Warning! This file is autogenerated.
#include <boost/text/normalize.hpp>
#include <boost/text/utility.hpp>

#include <gtest/gtest.h>

#include <algorithm>



TEST(normalization, nfd_036_000)
{
    // BEB0;BEB0;1108 1163 11BF;BEB0;1108 1163 11BF; 
    // (뺰; 뺰; 뺰; 뺰; 뺰; ) HANGUL SYLLABLE BBYAK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEB0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEB0 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1163, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEB0 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1163, 0x11BF }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_001)
{
    // BEB1;BEB1;1108 1163 11C0;BEB1;1108 1163 11C0; 
    // (뺱; 뺱; 뺱; 뺱; 뺱; ) HANGUL SYLLABLE BBYAT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEB1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEB1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1163, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEB1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1163, 0x11C0 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_002)
{
    // BEB2;BEB2;1108 1163 11C1;BEB2;1108 1163 11C1; 
    // (뺲; 뺲; 뺲; 뺲; 뺲; ) HANGUL SYLLABLE BBYAP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEB2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEB2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1163, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEB2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1163, 0x11C1 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_003)
{
    // BEB3;BEB3;1108 1163 11C2;BEB3;1108 1163 11C2; 
    // (뺳; 뺳; 뺳; 뺳; 뺳; ) HANGUL SYLLABLE BBYAH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEB3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEB3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1163, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEB3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1163, 0x11C2 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_004)
{
    // BEB4;BEB4;1108 1164;BEB4;1108 1164; 
    // (뺴; 뺴; 뺴; 뺴; 뺴; ) HANGUL SYLLABLE BBYAE
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEB4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEB4 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1108, 0x1164 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEB4 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1108, 0x1164 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_005)
{
    // BEB5;BEB5;1108 1164 11A8;BEB5;1108 1164 11A8; 
    // (뺵; 뺵; 뺵; 뺵; 뺵; ) HANGUL SYLLABLE BBYAEG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEB5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEB5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEB5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11A8 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_006)
{
    // BEB6;BEB6;1108 1164 11A9;BEB6;1108 1164 11A9; 
    // (뺶; 뺶; 뺶; 뺶; 뺶; ) HANGUL SYLLABLE BBYAEGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEB6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEB6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEB6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11A9 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_007)
{
    // BEB7;BEB7;1108 1164 11AA;BEB7;1108 1164 11AA; 
    // (뺷; 뺷; 뺷; 뺷; 뺷; ) HANGUL SYLLABLE BBYAEGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEB7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEB7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEB7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11AA }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_008)
{
    // BEB8;BEB8;1108 1164 11AB;BEB8;1108 1164 11AB; 
    // (뺸; 뺸; 뺸; 뺸; 뺸; ) HANGUL SYLLABLE BBYAEN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEB8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEB8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEB8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11AB }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_009)
{
    // BEB9;BEB9;1108 1164 11AC;BEB9;1108 1164 11AC; 
    // (뺹; 뺹; 뺹; 뺹; 뺹; ) HANGUL SYLLABLE BBYAENJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEB9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEB9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEB9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11AC }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_010)
{
    // BEBA;BEBA;1108 1164 11AD;BEBA;1108 1164 11AD; 
    // (뺺; 뺺; 뺺; 뺺; 뺺; ) HANGUL SYLLABLE BBYAENH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEBA }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEBA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEBA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11AD }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_011)
{
    // BEBB;BEBB;1108 1164 11AE;BEBB;1108 1164 11AE; 
    // (뺻; 뺻; 뺻; 뺻; 뺻; ) HANGUL SYLLABLE BBYAED
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEBB }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEBB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEBB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11AE }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_012)
{
    // BEBC;BEBC;1108 1164 11AF;BEBC;1108 1164 11AF; 
    // (뺼; 뺼; 뺼; 뺼; 뺼; ) HANGUL SYLLABLE BBYAEL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEBC }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEBC }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEBC }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11AF }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_013)
{
    // BEBD;BEBD;1108 1164 11B0;BEBD;1108 1164 11B0; 
    // (뺽; 뺽; 뺽; 뺽; 뺽; ) HANGUL SYLLABLE BBYAELG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEBD }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEBD }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEBD }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11B0 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_014)
{
    // BEBE;BEBE;1108 1164 11B1;BEBE;1108 1164 11B1; 
    // (뺾; 뺾; 뺾; 뺾; 뺾; ) HANGUL SYLLABLE BBYAELM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEBE }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEBE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEBE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11B1 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_015)
{
    // BEBF;BEBF;1108 1164 11B2;BEBF;1108 1164 11B2; 
    // (뺿; 뺿; 뺿; 뺿; 뺿; ) HANGUL SYLLABLE BBYAELB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEBF }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEBF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEBF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11B2 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_016)
{
    // BEC0;BEC0;1108 1164 11B3;BEC0;1108 1164 11B3; 
    // (뻀; 뻀; 뻀; 뻀; 뻀; ) HANGUL SYLLABLE BBYAELS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEC0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEC0 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEC0 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11B3 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_017)
{
    // BEC1;BEC1;1108 1164 11B4;BEC1;1108 1164 11B4; 
    // (뻁; 뻁; 뻁; 뻁; 뻁; ) HANGUL SYLLABLE BBYAELT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEC1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEC1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEC1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11B4 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_018)
{
    // BEC2;BEC2;1108 1164 11B5;BEC2;1108 1164 11B5; 
    // (뻂; 뻂; 뻂; 뻂; 뻂; ) HANGUL SYLLABLE BBYAELP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEC2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEC2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEC2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11B5 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_019)
{
    // BEC3;BEC3;1108 1164 11B6;BEC3;1108 1164 11B6; 
    // (뻃; 뻃; 뻃; 뻃; 뻃; ) HANGUL SYLLABLE BBYAELH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEC3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEC3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEC3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11B6 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_020)
{
    // BEC4;BEC4;1108 1164 11B7;BEC4;1108 1164 11B7; 
    // (뻄; 뻄; 뻄; 뻄; 뻄; ) HANGUL SYLLABLE BBYAEM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEC4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEC4 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEC4 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11B7 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_021)
{
    // BEC5;BEC5;1108 1164 11B8;BEC5;1108 1164 11B8; 
    // (뻅; 뻅; 뻅; 뻅; 뻅; ) HANGUL SYLLABLE BBYAEB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEC5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEC5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEC5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11B8 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_022)
{
    // BEC6;BEC6;1108 1164 11B9;BEC6;1108 1164 11B9; 
    // (뻆; 뻆; 뻆; 뻆; 뻆; ) HANGUL SYLLABLE BBYAEBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEC6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEC6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEC6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11B9 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_023)
{
    // BEC7;BEC7;1108 1164 11BA;BEC7;1108 1164 11BA; 
    // (뻇; 뻇; 뻇; 뻇; 뻇; ) HANGUL SYLLABLE BBYAES
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEC7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEC7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEC7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11BA }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_024)
{
    // BEC8;BEC8;1108 1164 11BB;BEC8;1108 1164 11BB; 
    // (뻈; 뻈; 뻈; 뻈; 뻈; ) HANGUL SYLLABLE BBYAESS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEC8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEC8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEC8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11BB }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_025)
{
    // BEC9;BEC9;1108 1164 11BC;BEC9;1108 1164 11BC; 
    // (뻉; 뻉; 뻉; 뻉; 뻉; ) HANGUL SYLLABLE BBYAENG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEC9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEC9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEC9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11BC }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_026)
{
    // BECA;BECA;1108 1164 11BD;BECA;1108 1164 11BD; 
    // (뻊; 뻊; 뻊; 뻊; 뻊; ) HANGUL SYLLABLE BBYAEJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBECA }};
        std::array<uint32_t, 1> const c2 = {{ 0xBECA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xBECA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11BD }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_027)
{
    // BECB;BECB;1108 1164 11BE;BECB;1108 1164 11BE; 
    // (뻋; 뻋; 뻋; 뻋; 뻋; ) HANGUL SYLLABLE BBYAEC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBECB }};
        std::array<uint32_t, 1> const c2 = {{ 0xBECB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xBECB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11BE }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_028)
{
    // BECC;BECC;1108 1164 11BF;BECC;1108 1164 11BF; 
    // (뻌; 뻌; 뻌; 뻌; 뻌; ) HANGUL SYLLABLE BBYAEK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBECC }};
        std::array<uint32_t, 1> const c2 = {{ 0xBECC }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xBECC }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11BF }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_029)
{
    // BECD;BECD;1108 1164 11C0;BECD;1108 1164 11C0; 
    // (뻍; 뻍; 뻍; 뻍; 뻍; ) HANGUL SYLLABLE BBYAET
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBECD }};
        std::array<uint32_t, 1> const c2 = {{ 0xBECD }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBECD }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11C0 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_030)
{
    // BECE;BECE;1108 1164 11C1;BECE;1108 1164 11C1; 
    // (뻎; 뻎; 뻎; 뻎; 뻎; ) HANGUL SYLLABLE BBYAEP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBECE }};
        std::array<uint32_t, 1> const c2 = {{ 0xBECE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBECE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11C1 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_031)
{
    // BECF;BECF;1108 1164 11C2;BECF;1108 1164 11C2; 
    // (뻏; 뻏; 뻏; 뻏; 뻏; ) HANGUL SYLLABLE BBYAEH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBECF }};
        std::array<uint32_t, 1> const c2 = {{ 0xBECF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1164, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBECF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1164, 0x11C2 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_032)
{
    // BED0;BED0;1108 1165;BED0;1108 1165; 
    // (뻐; 뻐; 뻐; 뻐; 뻐; ) HANGUL SYLLABLE BBEO
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBED0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBED0 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1108, 0x1165 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBED0 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1108, 0x1165 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_033)
{
    // BED1;BED1;1108 1165 11A8;BED1;1108 1165 11A8; 
    // (뻑; 뻑; 뻑; 뻑; 뻑; ) HANGUL SYLLABLE BBEOG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBED1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBED1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBED1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11A8 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_034)
{
    // BED2;BED2;1108 1165 11A9;BED2;1108 1165 11A9; 
    // (뻒; 뻒; 뻒; 뻒; 뻒; ) HANGUL SYLLABLE BBEOGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBED2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBED2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBED2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11A9 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_035)
{
    // BED3;BED3;1108 1165 11AA;BED3;1108 1165 11AA; 
    // (뻓; 뻓; 뻓; 뻓; 뻓; ) HANGUL SYLLABLE BBEOGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBED3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBED3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xBED3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11AA }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_036)
{
    // BED4;BED4;1108 1165 11AB;BED4;1108 1165 11AB; 
    // (뻔; 뻔; 뻔; 뻔; 뻔; ) HANGUL SYLLABLE BBEON
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBED4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBED4 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xBED4 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11AB }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_037)
{
    // BED5;BED5;1108 1165 11AC;BED5;1108 1165 11AC; 
    // (뻕; 뻕; 뻕; 뻕; 뻕; ) HANGUL SYLLABLE BBEONJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBED5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBED5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xBED5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11AC }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_038)
{
    // BED6;BED6;1108 1165 11AD;BED6;1108 1165 11AD; 
    // (뻖; 뻖; 뻖; 뻖; 뻖; ) HANGUL SYLLABLE BBEONH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBED6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBED6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xBED6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11AD }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_039)
{
    // BED7;BED7;1108 1165 11AE;BED7;1108 1165 11AE; 
    // (뻗; 뻗; 뻗; 뻗; 뻗; ) HANGUL SYLLABLE BBEOD
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBED7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBED7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xBED7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11AE }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_040)
{
    // BED8;BED8;1108 1165 11AF;BED8;1108 1165 11AF; 
    // (뻘; 뻘; 뻘; 뻘; 뻘; ) HANGUL SYLLABLE BBEOL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBED8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBED8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xBED8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11AF }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_041)
{
    // BED9;BED9;1108 1165 11B0;BED9;1108 1165 11B0; 
    // (뻙; 뻙; 뻙; 뻙; 뻙; ) HANGUL SYLLABLE BBEOLG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBED9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBED9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBED9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11B0 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_042)
{
    // BEDA;BEDA;1108 1165 11B1;BEDA;1108 1165 11B1; 
    // (뻚; 뻚; 뻚; 뻚; 뻚; ) HANGUL SYLLABLE BBEOLM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEDA }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEDA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEDA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11B1 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_043)
{
    // BEDB;BEDB;1108 1165 11B2;BEDB;1108 1165 11B2; 
    // (뻛; 뻛; 뻛; 뻛; 뻛; ) HANGUL SYLLABLE BBEOLB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEDB }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEDB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEDB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11B2 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_044)
{
    // BEDC;BEDC;1108 1165 11B3;BEDC;1108 1165 11B3; 
    // (뻜; 뻜; 뻜; 뻜; 뻜; ) HANGUL SYLLABLE BBEOLS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEDC }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEDC }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEDC }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11B3 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_045)
{
    // BEDD;BEDD;1108 1165 11B4;BEDD;1108 1165 11B4; 
    // (뻝; 뻝; 뻝; 뻝; 뻝; ) HANGUL SYLLABLE BBEOLT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEDD }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEDD }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEDD }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11B4 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_046)
{
    // BEDE;BEDE;1108 1165 11B5;BEDE;1108 1165 11B5; 
    // (뻞; 뻞; 뻞; 뻞; 뻞; ) HANGUL SYLLABLE BBEOLP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEDE }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEDE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEDE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11B5 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_047)
{
    // BEDF;BEDF;1108 1165 11B6;BEDF;1108 1165 11B6; 
    // (뻟; 뻟; 뻟; 뻟; 뻟; ) HANGUL SYLLABLE BBEOLH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEDF }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEDF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEDF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11B6 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_048)
{
    // BEE0;BEE0;1108 1165 11B7;BEE0;1108 1165 11B7; 
    // (뻠; 뻠; 뻠; 뻠; 뻠; ) HANGUL SYLLABLE BBEOM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEE0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEE0 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEE0 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11B7 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_049)
{
    // BEE1;BEE1;1108 1165 11B8;BEE1;1108 1165 11B8; 
    // (뻡; 뻡; 뻡; 뻡; 뻡; ) HANGUL SYLLABLE BBEOB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEE1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEE1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEE1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11B8 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_050)
{
    // BEE2;BEE2;1108 1165 11B9;BEE2;1108 1165 11B9; 
    // (뻢; 뻢; 뻢; 뻢; 뻢; ) HANGUL SYLLABLE BBEOBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEE2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEE2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEE2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11B9 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_051)
{
    // BEE3;BEE3;1108 1165 11BA;BEE3;1108 1165 11BA; 
    // (뻣; 뻣; 뻣; 뻣; 뻣; ) HANGUL SYLLABLE BBEOS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEE3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEE3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEE3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11BA }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_052)
{
    // BEE4;BEE4;1108 1165 11BB;BEE4;1108 1165 11BB; 
    // (뻤; 뻤; 뻤; 뻤; 뻤; ) HANGUL SYLLABLE BBEOSS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEE4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEE4 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEE4 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11BB }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_053)
{
    // BEE5;BEE5;1108 1165 11BC;BEE5;1108 1165 11BC; 
    // (뻥; 뻥; 뻥; 뻥; 뻥; ) HANGUL SYLLABLE BBEONG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEE5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEE5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEE5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11BC }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_054)
{
    // BEE6;BEE6;1108 1165 11BD;BEE6;1108 1165 11BD; 
    // (뻦; 뻦; 뻦; 뻦; 뻦; ) HANGUL SYLLABLE BBEOJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEE6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEE6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEE6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11BD }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_055)
{
    // BEE7;BEE7;1108 1165 11BE;BEE7;1108 1165 11BE; 
    // (뻧; 뻧; 뻧; 뻧; 뻧; ) HANGUL SYLLABLE BBEOC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEE7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEE7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEE7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11BE }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_056)
{
    // BEE8;BEE8;1108 1165 11BF;BEE8;1108 1165 11BF; 
    // (뻨; 뻨; 뻨; 뻨; 뻨; ) HANGUL SYLLABLE BBEOK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEE8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEE8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEE8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11BF }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_057)
{
    // BEE9;BEE9;1108 1165 11C0;BEE9;1108 1165 11C0; 
    // (뻩; 뻩; 뻩; 뻩; 뻩; ) HANGUL SYLLABLE BBEOT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEE9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEE9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEE9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11C0 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_058)
{
    // BEEA;BEEA;1108 1165 11C1;BEEA;1108 1165 11C1; 
    // (뻪; 뻪; 뻪; 뻪; 뻪; ) HANGUL SYLLABLE BBEOP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEEA }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEEA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEEA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11C1 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_059)
{
    // BEEB;BEEB;1108 1165 11C2;BEEB;1108 1165 11C2; 
    // (뻫; 뻫; 뻫; 뻫; 뻫; ) HANGUL SYLLABLE BBEOH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEEB }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEEB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1165, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEEB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1165, 0x11C2 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_060)
{
    // BEEC;BEEC;1108 1166;BEEC;1108 1166; 
    // (뻬; 뻬; 뻬; 뻬; 뻬; ) HANGUL SYLLABLE BBE
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEEC }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEEC }};
        std::array<uint32_t, 2> const c3 = {{ 0x1108, 0x1166 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEEC }};
        std::array<uint32_t, 2> const c5 = {{ 0x1108, 0x1166 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_061)
{
    // BEED;BEED;1108 1166 11A8;BEED;1108 1166 11A8; 
    // (뻭; 뻭; 뻭; 뻭; 뻭; ) HANGUL SYLLABLE BBEG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEED }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEED }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEED }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11A8 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_062)
{
    // BEEE;BEEE;1108 1166 11A9;BEEE;1108 1166 11A9; 
    // (뻮; 뻮; 뻮; 뻮; 뻮; ) HANGUL SYLLABLE BBEGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEEE }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEEE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEEE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11A9 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_063)
{
    // BEEF;BEEF;1108 1166 11AA;BEEF;1108 1166 11AA; 
    // (뻯; 뻯; 뻯; 뻯; 뻯; ) HANGUL SYLLABLE BBEGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEEF }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEEF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEEF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11AA }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_064)
{
    // BEF0;BEF0;1108 1166 11AB;BEF0;1108 1166 11AB; 
    // (뻰; 뻰; 뻰; 뻰; 뻰; ) HANGUL SYLLABLE BBEN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEF0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEF0 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEF0 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11AB }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_065)
{
    // BEF1;BEF1;1108 1166 11AC;BEF1;1108 1166 11AC; 
    // (뻱; 뻱; 뻱; 뻱; 뻱; ) HANGUL SYLLABLE BBENJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEF1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEF1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEF1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11AC }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_066)
{
    // BEF2;BEF2;1108 1166 11AD;BEF2;1108 1166 11AD; 
    // (뻲; 뻲; 뻲; 뻲; 뻲; ) HANGUL SYLLABLE BBENH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEF2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEF2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEF2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11AD }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_067)
{
    // BEF3;BEF3;1108 1166 11AE;BEF3;1108 1166 11AE; 
    // (뻳; 뻳; 뻳; 뻳; 뻳; ) HANGUL SYLLABLE BBED
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEF3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEF3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEF3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11AE }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_068)
{
    // BEF4;BEF4;1108 1166 11AF;BEF4;1108 1166 11AF; 
    // (뻴; 뻴; 뻴; 뻴; 뻴; ) HANGUL SYLLABLE BBEL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEF4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEF4 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEF4 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11AF }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_069)
{
    // BEF5;BEF5;1108 1166 11B0;BEF5;1108 1166 11B0; 
    // (뻵; 뻵; 뻵; 뻵; 뻵; ) HANGUL SYLLABLE BBELG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEF5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEF5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEF5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11B0 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_070)
{
    // BEF6;BEF6;1108 1166 11B1;BEF6;1108 1166 11B1; 
    // (뻶; 뻶; 뻶; 뻶; 뻶; ) HANGUL SYLLABLE BBELM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEF6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEF6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEF6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11B1 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_071)
{
    // BEF7;BEF7;1108 1166 11B2;BEF7;1108 1166 11B2; 
    // (뻷; 뻷; 뻷; 뻷; 뻷; ) HANGUL SYLLABLE BBELB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEF7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEF7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEF7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11B2 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_072)
{
    // BEF8;BEF8;1108 1166 11B3;BEF8;1108 1166 11B3; 
    // (뻸; 뻸; 뻸; 뻸; 뻸; ) HANGUL SYLLABLE BBELS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEF8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEF8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEF8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11B3 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_073)
{
    // BEF9;BEF9;1108 1166 11B4;BEF9;1108 1166 11B4; 
    // (뻹; 뻹; 뻹; 뻹; 뻹; ) HANGUL SYLLABLE BBELT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEF9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEF9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEF9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11B4 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_074)
{
    // BEFA;BEFA;1108 1166 11B5;BEFA;1108 1166 11B5; 
    // (뻺; 뻺; 뻺; 뻺; 뻺; ) HANGUL SYLLABLE BBELP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEFA }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEFA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEFA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11B5 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_075)
{
    // BEFB;BEFB;1108 1166 11B6;BEFB;1108 1166 11B6; 
    // (뻻; 뻻; 뻻; 뻻; 뻻; ) HANGUL SYLLABLE BBELH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEFB }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEFB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEFB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11B6 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_076)
{
    // BEFC;BEFC;1108 1166 11B7;BEFC;1108 1166 11B7; 
    // (뻼; 뻼; 뻼; 뻼; 뻼; ) HANGUL SYLLABLE BBEM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEFC }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEFC }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEFC }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11B7 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_077)
{
    // BEFD;BEFD;1108 1166 11B8;BEFD;1108 1166 11B8; 
    // (뻽; 뻽; 뻽; 뻽; 뻽; ) HANGUL SYLLABLE BBEB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEFD }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEFD }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEFD }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11B8 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_078)
{
    // BEFE;BEFE;1108 1166 11B9;BEFE;1108 1166 11B9; 
    // (뻾; 뻾; 뻾; 뻾; 뻾; ) HANGUL SYLLABLE BBEBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEFE }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEFE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEFE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11B9 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_079)
{
    // BEFF;BEFF;1108 1166 11BA;BEFF;1108 1166 11BA; 
    // (뻿; 뻿; 뻿; 뻿; 뻿; ) HANGUL SYLLABLE BBES
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBEFF }};
        std::array<uint32_t, 1> const c2 = {{ 0xBEFF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xBEFF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11BA }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_080)
{
    // BF00;BF00;1108 1166 11BB;BF00;1108 1166 11BB; 
    // (뼀; 뼀; 뼀; 뼀; 뼀; ) HANGUL SYLLABLE BBESS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF00 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF00 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF00 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11BB }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_081)
{
    // BF01;BF01;1108 1166 11BC;BF01;1108 1166 11BC; 
    // (뼁; 뼁; 뼁; 뼁; 뼁; ) HANGUL SYLLABLE BBENG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF01 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF01 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF01 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11BC }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_082)
{
    // BF02;BF02;1108 1166 11BD;BF02;1108 1166 11BD; 
    // (뼂; 뼂; 뼂; 뼂; 뼂; ) HANGUL SYLLABLE BBEJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF02 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF02 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF02 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11BD }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_083)
{
    // BF03;BF03;1108 1166 11BE;BF03;1108 1166 11BE; 
    // (뼃; 뼃; 뼃; 뼃; 뼃; ) HANGUL SYLLABLE BBEC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF03 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF03 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF03 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11BE }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_084)
{
    // BF04;BF04;1108 1166 11BF;BF04;1108 1166 11BF; 
    // (뼄; 뼄; 뼄; 뼄; 뼄; ) HANGUL SYLLABLE BBEK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF04 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF04 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF04 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11BF }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_085)
{
    // BF05;BF05;1108 1166 11C0;BF05;1108 1166 11C0; 
    // (뼅; 뼅; 뼅; 뼅; 뼅; ) HANGUL SYLLABLE BBET
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF05 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF05 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF05 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11C0 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_086)
{
    // BF06;BF06;1108 1166 11C1;BF06;1108 1166 11C1; 
    // (뼆; 뼆; 뼆; 뼆; 뼆; ) HANGUL SYLLABLE BBEP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF06 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF06 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF06 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11C1 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_087)
{
    // BF07;BF07;1108 1166 11C2;BF07;1108 1166 11C2; 
    // (뼇; 뼇; 뼇; 뼇; 뼇; ) HANGUL SYLLABLE BBEH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF07 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF07 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1166, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF07 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1166, 0x11C2 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_088)
{
    // BF08;BF08;1108 1167;BF08;1108 1167; 
    // (뼈; 뼈; 뼈; 뼈; 뼈; ) HANGUL SYLLABLE BBYEO
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF08 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF08 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1108, 0x1167 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF08 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1108, 0x1167 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_089)
{
    // BF09;BF09;1108 1167 11A8;BF09;1108 1167 11A8; 
    // (뼉; 뼉; 뼉; 뼉; 뼉; ) HANGUL SYLLABLE BBYEOG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF09 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF09 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF09 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11A8 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_090)
{
    // BF0A;BF0A;1108 1167 11A9;BF0A;1108 1167 11A9; 
    // (뼊; 뼊; 뼊; 뼊; 뼊; ) HANGUL SYLLABLE BBYEOGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF0A }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF0A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF0A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11A9 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_091)
{
    // BF0B;BF0B;1108 1167 11AA;BF0B;1108 1167 11AA; 
    // (뼋; 뼋; 뼋; 뼋; 뼋; ) HANGUL SYLLABLE BBYEOGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF0B }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF0B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF0B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11AA }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_092)
{
    // BF0C;BF0C;1108 1167 11AB;BF0C;1108 1167 11AB; 
    // (뼌; 뼌; 뼌; 뼌; 뼌; ) HANGUL SYLLABLE BBYEON
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF0C }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF0C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF0C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11AB }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_093)
{
    // BF0D;BF0D;1108 1167 11AC;BF0D;1108 1167 11AC; 
    // (뼍; 뼍; 뼍; 뼍; 뼍; ) HANGUL SYLLABLE BBYEONJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF0D }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF0D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF0D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11AC }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_094)
{
    // BF0E;BF0E;1108 1167 11AD;BF0E;1108 1167 11AD; 
    // (뼎; 뼎; 뼎; 뼎; 뼎; ) HANGUL SYLLABLE BBYEONH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF0E }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF0E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF0E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11AD }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_095)
{
    // BF0F;BF0F;1108 1167 11AE;BF0F;1108 1167 11AE; 
    // (뼏; 뼏; 뼏; 뼏; 뼏; ) HANGUL SYLLABLE BBYEOD
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF0F }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF0F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF0F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11AE }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_096)
{
    // BF10;BF10;1108 1167 11AF;BF10;1108 1167 11AF; 
    // (뼐; 뼐; 뼐; 뼐; 뼐; ) HANGUL SYLLABLE BBYEOL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF10 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF10 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF10 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11AF }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_097)
{
    // BF11;BF11;1108 1167 11B0;BF11;1108 1167 11B0; 
    // (뼑; 뼑; 뼑; 뼑; 뼑; ) HANGUL SYLLABLE BBYEOLG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF11 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF11 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF11 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11B0 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_098)
{
    // BF12;BF12;1108 1167 11B1;BF12;1108 1167 11B1; 
    // (뼒; 뼒; 뼒; 뼒; 뼒; ) HANGUL SYLLABLE BBYEOLM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF12 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF12 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF12 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11B1 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_099)
{
    // BF13;BF13;1108 1167 11B2;BF13;1108 1167 11B2; 
    // (뼓; 뼓; 뼓; 뼓; 뼓; ) HANGUL SYLLABLE BBYEOLB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF13 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF13 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF13 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11B2 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_100)
{
    // BF14;BF14;1108 1167 11B3;BF14;1108 1167 11B3; 
    // (뼔; 뼔; 뼔; 뼔; 뼔; ) HANGUL SYLLABLE BBYEOLS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF14 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF14 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF14 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11B3 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_101)
{
    // BF15;BF15;1108 1167 11B4;BF15;1108 1167 11B4; 
    // (뼕; 뼕; 뼕; 뼕; 뼕; ) HANGUL SYLLABLE BBYEOLT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF15 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF15 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF15 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11B4 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_102)
{
    // BF16;BF16;1108 1167 11B5;BF16;1108 1167 11B5; 
    // (뼖; 뼖; 뼖; 뼖; 뼖; ) HANGUL SYLLABLE BBYEOLP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF16 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF16 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF16 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11B5 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_103)
{
    // BF17;BF17;1108 1167 11B6;BF17;1108 1167 11B6; 
    // (뼗; 뼗; 뼗; 뼗; 뼗; ) HANGUL SYLLABLE BBYEOLH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF17 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF17 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF17 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11B6 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_104)
{
    // BF18;BF18;1108 1167 11B7;BF18;1108 1167 11B7; 
    // (뼘; 뼘; 뼘; 뼘; 뼘; ) HANGUL SYLLABLE BBYEOM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF18 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF18 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF18 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11B7 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_105)
{
    // BF19;BF19;1108 1167 11B8;BF19;1108 1167 11B8; 
    // (뼙; 뼙; 뼙; 뼙; 뼙; ) HANGUL SYLLABLE BBYEOB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF19 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF19 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF19 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11B8 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_106)
{
    // BF1A;BF1A;1108 1167 11B9;BF1A;1108 1167 11B9; 
    // (뼚; 뼚; 뼚; 뼚; 뼚; ) HANGUL SYLLABLE BBYEOBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF1A }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF1A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF1A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11B9 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_107)
{
    // BF1B;BF1B;1108 1167 11BA;BF1B;1108 1167 11BA; 
    // (뼛; 뼛; 뼛; 뼛; 뼛; ) HANGUL SYLLABLE BBYEOS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF1B }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF1B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF1B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11BA }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_108)
{
    // BF1C;BF1C;1108 1167 11BB;BF1C;1108 1167 11BB; 
    // (뼜; 뼜; 뼜; 뼜; 뼜; ) HANGUL SYLLABLE BBYEOSS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF1C }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF1C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF1C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11BB }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_109)
{
    // BF1D;BF1D;1108 1167 11BC;BF1D;1108 1167 11BC; 
    // (뼝; 뼝; 뼝; 뼝; 뼝; ) HANGUL SYLLABLE BBYEONG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF1D }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF1D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF1D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11BC }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_110)
{
    // BF1E;BF1E;1108 1167 11BD;BF1E;1108 1167 11BD; 
    // (뼞; 뼞; 뼞; 뼞; 뼞; ) HANGUL SYLLABLE BBYEOJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF1E }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF1E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF1E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11BD }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_111)
{
    // BF1F;BF1F;1108 1167 11BE;BF1F;1108 1167 11BE; 
    // (뼟; 뼟; 뼟; 뼟; 뼟; ) HANGUL SYLLABLE BBYEOC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF1F }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF1F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF1F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11BE }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_112)
{
    // BF20;BF20;1108 1167 11BF;BF20;1108 1167 11BF; 
    // (뼠; 뼠; 뼠; 뼠; 뼠; ) HANGUL SYLLABLE BBYEOK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF20 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF20 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF20 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11BF }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_113)
{
    // BF21;BF21;1108 1167 11C0;BF21;1108 1167 11C0; 
    // (뼡; 뼡; 뼡; 뼡; 뼡; ) HANGUL SYLLABLE BBYEOT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF21 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF21 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF21 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11C0 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_114)
{
    // BF22;BF22;1108 1167 11C1;BF22;1108 1167 11C1; 
    // (뼢; 뼢; 뼢; 뼢; 뼢; ) HANGUL SYLLABLE BBYEOP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF22 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF22 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF22 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11C1 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_115)
{
    // BF23;BF23;1108 1167 11C2;BF23;1108 1167 11C2; 
    // (뼣; 뼣; 뼣; 뼣; 뼣; ) HANGUL SYLLABLE BBYEOH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF23 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF23 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1167, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF23 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1167, 0x11C2 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_116)
{
    // BF24;BF24;1108 1168;BF24;1108 1168; 
    // (뼤; 뼤; 뼤; 뼤; 뼤; ) HANGUL SYLLABLE BBYE
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF24 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF24 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1108, 0x1168 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF24 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1108, 0x1168 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_117)
{
    // BF25;BF25;1108 1168 11A8;BF25;1108 1168 11A8; 
    // (뼥; 뼥; 뼥; 뼥; 뼥; ) HANGUL SYLLABLE BBYEG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF25 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF25 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF25 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11A8 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_118)
{
    // BF26;BF26;1108 1168 11A9;BF26;1108 1168 11A9; 
    // (뼦; 뼦; 뼦; 뼦; 뼦; ) HANGUL SYLLABLE BBYEGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF26 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF26 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF26 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11A9 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_119)
{
    // BF27;BF27;1108 1168 11AA;BF27;1108 1168 11AA; 
    // (뼧; 뼧; 뼧; 뼧; 뼧; ) HANGUL SYLLABLE BBYEGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF27 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF27 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF27 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11AA }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_120)
{
    // BF28;BF28;1108 1168 11AB;BF28;1108 1168 11AB; 
    // (뼨; 뼨; 뼨; 뼨; 뼨; ) HANGUL SYLLABLE BBYEN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF28 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF28 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF28 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11AB }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_121)
{
    // BF29;BF29;1108 1168 11AC;BF29;1108 1168 11AC; 
    // (뼩; 뼩; 뼩; 뼩; 뼩; ) HANGUL SYLLABLE BBYENJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF29 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF29 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF29 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11AC }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_122)
{
    // BF2A;BF2A;1108 1168 11AD;BF2A;1108 1168 11AD; 
    // (뼪; 뼪; 뼪; 뼪; 뼪; ) HANGUL SYLLABLE BBYENH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF2A }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF2A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF2A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11AD }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_123)
{
    // BF2B;BF2B;1108 1168 11AE;BF2B;1108 1168 11AE; 
    // (뼫; 뼫; 뼫; 뼫; 뼫; ) HANGUL SYLLABLE BBYED
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF2B }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF2B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF2B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11AE }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_124)
{
    // BF2C;BF2C;1108 1168 11AF;BF2C;1108 1168 11AF; 
    // (뼬; 뼬; 뼬; 뼬; 뼬; ) HANGUL SYLLABLE BBYEL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF2C }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF2C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF2C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11AF }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_125)
{
    // BF2D;BF2D;1108 1168 11B0;BF2D;1108 1168 11B0; 
    // (뼭; 뼭; 뼭; 뼭; 뼭; ) HANGUL SYLLABLE BBYELG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF2D }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF2D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF2D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11B0 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_126)
{
    // BF2E;BF2E;1108 1168 11B1;BF2E;1108 1168 11B1; 
    // (뼮; 뼮; 뼮; 뼮; 뼮; ) HANGUL SYLLABLE BBYELM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF2E }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF2E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF2E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11B1 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_127)
{
    // BF2F;BF2F;1108 1168 11B2;BF2F;1108 1168 11B2; 
    // (뼯; 뼯; 뼯; 뼯; 뼯; ) HANGUL SYLLABLE BBYELB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF2F }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF2F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF2F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11B2 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_128)
{
    // BF30;BF30;1108 1168 11B3;BF30;1108 1168 11B3; 
    // (뼰; 뼰; 뼰; 뼰; 뼰; ) HANGUL SYLLABLE BBYELS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF30 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF30 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF30 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11B3 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_129)
{
    // BF31;BF31;1108 1168 11B4;BF31;1108 1168 11B4; 
    // (뼱; 뼱; 뼱; 뼱; 뼱; ) HANGUL SYLLABLE BBYELT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF31 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF31 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF31 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11B4 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_130)
{
    // BF32;BF32;1108 1168 11B5;BF32;1108 1168 11B5; 
    // (뼲; 뼲; 뼲; 뼲; 뼲; ) HANGUL SYLLABLE BBYELP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF32 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF32 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF32 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11B5 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_131)
{
    // BF33;BF33;1108 1168 11B6;BF33;1108 1168 11B6; 
    // (뼳; 뼳; 뼳; 뼳; 뼳; ) HANGUL SYLLABLE BBYELH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF33 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF33 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF33 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11B6 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_132)
{
    // BF34;BF34;1108 1168 11B7;BF34;1108 1168 11B7; 
    // (뼴; 뼴; 뼴; 뼴; 뼴; ) HANGUL SYLLABLE BBYEM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF34 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF34 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF34 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11B7 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_133)
{
    // BF35;BF35;1108 1168 11B8;BF35;1108 1168 11B8; 
    // (뼵; 뼵; 뼵; 뼵; 뼵; ) HANGUL SYLLABLE BBYEB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF35 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF35 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF35 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11B8 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_134)
{
    // BF36;BF36;1108 1168 11B9;BF36;1108 1168 11B9; 
    // (뼶; 뼶; 뼶; 뼶; 뼶; ) HANGUL SYLLABLE BBYEBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF36 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF36 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF36 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11B9 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_135)
{
    // BF37;BF37;1108 1168 11BA;BF37;1108 1168 11BA; 
    // (뼷; 뼷; 뼷; 뼷; 뼷; ) HANGUL SYLLABLE BBYES
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF37 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF37 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF37 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11BA }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_136)
{
    // BF38;BF38;1108 1168 11BB;BF38;1108 1168 11BB; 
    // (뼸; 뼸; 뼸; 뼸; 뼸; ) HANGUL SYLLABLE BBYESS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF38 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF38 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF38 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11BB }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_137)
{
    // BF39;BF39;1108 1168 11BC;BF39;1108 1168 11BC; 
    // (뼹; 뼹; 뼹; 뼹; 뼹; ) HANGUL SYLLABLE BBYENG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF39 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF39 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF39 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11BC }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_138)
{
    // BF3A;BF3A;1108 1168 11BD;BF3A;1108 1168 11BD; 
    // (뼺; 뼺; 뼺; 뼺; 뼺; ) HANGUL SYLLABLE BBYEJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF3A }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF3A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF3A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11BD }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_139)
{
    // BF3B;BF3B;1108 1168 11BE;BF3B;1108 1168 11BE; 
    // (뼻; 뼻; 뼻; 뼻; 뼻; ) HANGUL SYLLABLE BBYEC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF3B }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF3B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF3B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11BE }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_140)
{
    // BF3C;BF3C;1108 1168 11BF;BF3C;1108 1168 11BF; 
    // (뼼; 뼼; 뼼; 뼼; 뼼; ) HANGUL SYLLABLE BBYEK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF3C }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF3C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF3C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11BF }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_141)
{
    // BF3D;BF3D;1108 1168 11C0;BF3D;1108 1168 11C0; 
    // (뼽; 뼽; 뼽; 뼽; 뼽; ) HANGUL SYLLABLE BBYET
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF3D }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF3D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF3D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11C0 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_142)
{
    // BF3E;BF3E;1108 1168 11C1;BF3E;1108 1168 11C1; 
    // (뼾; 뼾; 뼾; 뼾; 뼾; ) HANGUL SYLLABLE BBYEP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF3E }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF3E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF3E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11C1 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_143)
{
    // BF3F;BF3F;1108 1168 11C2;BF3F;1108 1168 11C2; 
    // (뼿; 뼿; 뼿; 뼿; 뼿; ) HANGUL SYLLABLE BBYEH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF3F }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF3F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1168, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF3F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1168, 0x11C2 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_144)
{
    // BF40;BF40;1108 1169;BF40;1108 1169; 
    // (뽀; 뽀; 뽀; 뽀; 뽀; ) HANGUL SYLLABLE BBO
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF40 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF40 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1108, 0x1169 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF40 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1108, 0x1169 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_145)
{
    // BF41;BF41;1108 1169 11A8;BF41;1108 1169 11A8; 
    // (뽁; 뽁; 뽁; 뽁; 뽁; ) HANGUL SYLLABLE BBOG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF41 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF41 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF41 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11A8 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_146)
{
    // BF42;BF42;1108 1169 11A9;BF42;1108 1169 11A9; 
    // (뽂; 뽂; 뽂; 뽂; 뽂; ) HANGUL SYLLABLE BBOGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF42 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF42 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF42 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11A9 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_147)
{
    // BF43;BF43;1108 1169 11AA;BF43;1108 1169 11AA; 
    // (뽃; 뽃; 뽃; 뽃; 뽃; ) HANGUL SYLLABLE BBOGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF43 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF43 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF43 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11AA }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_148)
{
    // BF44;BF44;1108 1169 11AB;BF44;1108 1169 11AB; 
    // (뽄; 뽄; 뽄; 뽄; 뽄; ) HANGUL SYLLABLE BBON
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF44 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF44 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF44 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11AB }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_149)
{
    // BF45;BF45;1108 1169 11AC;BF45;1108 1169 11AC; 
    // (뽅; 뽅; 뽅; 뽅; 뽅; ) HANGUL SYLLABLE BBONJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF45 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF45 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF45 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11AC }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_150)
{
    // BF46;BF46;1108 1169 11AD;BF46;1108 1169 11AD; 
    // (뽆; 뽆; 뽆; 뽆; 뽆; ) HANGUL SYLLABLE BBONH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF46 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF46 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF46 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11AD }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_151)
{
    // BF47;BF47;1108 1169 11AE;BF47;1108 1169 11AE; 
    // (뽇; 뽇; 뽇; 뽇; 뽇; ) HANGUL SYLLABLE BBOD
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF47 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF47 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF47 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11AE }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_152)
{
    // BF48;BF48;1108 1169 11AF;BF48;1108 1169 11AF; 
    // (뽈; 뽈; 뽈; 뽈; 뽈; ) HANGUL SYLLABLE BBOL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF48 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF48 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF48 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11AF }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_153)
{
    // BF49;BF49;1108 1169 11B0;BF49;1108 1169 11B0; 
    // (뽉; 뽉; 뽉; 뽉; 뽉; ) HANGUL SYLLABLE BBOLG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF49 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF49 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF49 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11B0 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_154)
{
    // BF4A;BF4A;1108 1169 11B1;BF4A;1108 1169 11B1; 
    // (뽊; 뽊; 뽊; 뽊; 뽊; ) HANGUL SYLLABLE BBOLM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF4A }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF4A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF4A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11B1 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_155)
{
    // BF4B;BF4B;1108 1169 11B2;BF4B;1108 1169 11B2; 
    // (뽋; 뽋; 뽋; 뽋; 뽋; ) HANGUL SYLLABLE BBOLB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF4B }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF4B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF4B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11B2 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_156)
{
    // BF4C;BF4C;1108 1169 11B3;BF4C;1108 1169 11B3; 
    // (뽌; 뽌; 뽌; 뽌; 뽌; ) HANGUL SYLLABLE BBOLS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF4C }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF4C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF4C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11B3 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_157)
{
    // BF4D;BF4D;1108 1169 11B4;BF4D;1108 1169 11B4; 
    // (뽍; 뽍; 뽍; 뽍; 뽍; ) HANGUL SYLLABLE BBOLT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF4D }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF4D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF4D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11B4 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_158)
{
    // BF4E;BF4E;1108 1169 11B5;BF4E;1108 1169 11B5; 
    // (뽎; 뽎; 뽎; 뽎; 뽎; ) HANGUL SYLLABLE BBOLP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF4E }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF4E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF4E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11B5 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_159)
{
    // BF4F;BF4F;1108 1169 11B6;BF4F;1108 1169 11B6; 
    // (뽏; 뽏; 뽏; 뽏; 뽏; ) HANGUL SYLLABLE BBOLH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF4F }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF4F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF4F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11B6 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_160)
{
    // BF50;BF50;1108 1169 11B7;BF50;1108 1169 11B7; 
    // (뽐; 뽐; 뽐; 뽐; 뽐; ) HANGUL SYLLABLE BBOM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF50 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF50 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF50 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11B7 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_161)
{
    // BF51;BF51;1108 1169 11B8;BF51;1108 1169 11B8; 
    // (뽑; 뽑; 뽑; 뽑; 뽑; ) HANGUL SYLLABLE BBOB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF51 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF51 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF51 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11B8 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_162)
{
    // BF52;BF52;1108 1169 11B9;BF52;1108 1169 11B9; 
    // (뽒; 뽒; 뽒; 뽒; 뽒; ) HANGUL SYLLABLE BBOBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF52 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF52 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF52 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11B9 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_163)
{
    // BF53;BF53;1108 1169 11BA;BF53;1108 1169 11BA; 
    // (뽓; 뽓; 뽓; 뽓; 뽓; ) HANGUL SYLLABLE BBOS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF53 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF53 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF53 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11BA }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_164)
{
    // BF54;BF54;1108 1169 11BB;BF54;1108 1169 11BB; 
    // (뽔; 뽔; 뽔; 뽔; 뽔; ) HANGUL SYLLABLE BBOSS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF54 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF54 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF54 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11BB }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_165)
{
    // BF55;BF55;1108 1169 11BC;BF55;1108 1169 11BC; 
    // (뽕; 뽕; 뽕; 뽕; 뽕; ) HANGUL SYLLABLE BBONG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF55 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF55 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF55 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11BC }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_166)
{
    // BF56;BF56;1108 1169 11BD;BF56;1108 1169 11BD; 
    // (뽖; 뽖; 뽖; 뽖; 뽖; ) HANGUL SYLLABLE BBOJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF56 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF56 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF56 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11BD }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_167)
{
    // BF57;BF57;1108 1169 11BE;BF57;1108 1169 11BE; 
    // (뽗; 뽗; 뽗; 뽗; 뽗; ) HANGUL SYLLABLE BBOC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF57 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF57 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF57 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11BE }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_168)
{
    // BF58;BF58;1108 1169 11BF;BF58;1108 1169 11BF; 
    // (뽘; 뽘; 뽘; 뽘; 뽘; ) HANGUL SYLLABLE BBOK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF58 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF58 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF58 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11BF }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_169)
{
    // BF59;BF59;1108 1169 11C0;BF59;1108 1169 11C0; 
    // (뽙; 뽙; 뽙; 뽙; 뽙; ) HANGUL SYLLABLE BBOT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF59 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF59 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF59 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11C0 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_170)
{
    // BF5A;BF5A;1108 1169 11C1;BF5A;1108 1169 11C1; 
    // (뽚; 뽚; 뽚; 뽚; 뽚; ) HANGUL SYLLABLE BBOP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF5A }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF5A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF5A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11C1 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_171)
{
    // BF5B;BF5B;1108 1169 11C2;BF5B;1108 1169 11C2; 
    // (뽛; 뽛; 뽛; 뽛; 뽛; ) HANGUL SYLLABLE BBOH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF5B }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF5B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x1169, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF5B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x1169, 0x11C2 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_172)
{
    // BF5C;BF5C;1108 116A;BF5C;1108 116A; 
    // (뽜; 뽜; 뽜; 뽜; 뽜; ) HANGUL SYLLABLE BBWA
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF5C }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF5C }};
        std::array<uint32_t, 2> const c3 = {{ 0x1108, 0x116A }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF5C }};
        std::array<uint32_t, 2> const c5 = {{ 0x1108, 0x116A }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_173)
{
    // BF5D;BF5D;1108 116A 11A8;BF5D;1108 116A 11A8; 
    // (뽝; 뽝; 뽝; 뽝; 뽝; ) HANGUL SYLLABLE BBWAG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF5D }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF5D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF5D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11A8 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_174)
{
    // BF5E;BF5E;1108 116A 11A9;BF5E;1108 116A 11A9; 
    // (뽞; 뽞; 뽞; 뽞; 뽞; ) HANGUL SYLLABLE BBWAGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF5E }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF5E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF5E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11A9 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_175)
{
    // BF5F;BF5F;1108 116A 11AA;BF5F;1108 116A 11AA; 
    // (뽟; 뽟; 뽟; 뽟; 뽟; ) HANGUL SYLLABLE BBWAGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF5F }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF5F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF5F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11AA }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_176)
{
    // BF60;BF60;1108 116A 11AB;BF60;1108 116A 11AB; 
    // (뽠; 뽠; 뽠; 뽠; 뽠; ) HANGUL SYLLABLE BBWAN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF60 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF60 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF60 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11AB }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_177)
{
    // BF61;BF61;1108 116A 11AC;BF61;1108 116A 11AC; 
    // (뽡; 뽡; 뽡; 뽡; 뽡; ) HANGUL SYLLABLE BBWANJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF61 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF61 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF61 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11AC }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_178)
{
    // BF62;BF62;1108 116A 11AD;BF62;1108 116A 11AD; 
    // (뽢; 뽢; 뽢; 뽢; 뽢; ) HANGUL SYLLABLE BBWANH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF62 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF62 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF62 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11AD }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_179)
{
    // BF63;BF63;1108 116A 11AE;BF63;1108 116A 11AE; 
    // (뽣; 뽣; 뽣; 뽣; 뽣; ) HANGUL SYLLABLE BBWAD
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF63 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF63 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF63 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11AE }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_180)
{
    // BF64;BF64;1108 116A 11AF;BF64;1108 116A 11AF; 
    // (뽤; 뽤; 뽤; 뽤; 뽤; ) HANGUL SYLLABLE BBWAL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF64 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF64 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF64 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11AF }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_181)
{
    // BF65;BF65;1108 116A 11B0;BF65;1108 116A 11B0; 
    // (뽥; 뽥; 뽥; 뽥; 뽥; ) HANGUL SYLLABLE BBWALG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF65 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF65 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF65 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11B0 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_182)
{
    // BF66;BF66;1108 116A 11B1;BF66;1108 116A 11B1; 
    // (뽦; 뽦; 뽦; 뽦; 뽦; ) HANGUL SYLLABLE BBWALM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF66 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF66 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF66 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11B1 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_183)
{
    // BF67;BF67;1108 116A 11B2;BF67;1108 116A 11B2; 
    // (뽧; 뽧; 뽧; 뽧; 뽧; ) HANGUL SYLLABLE BBWALB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF67 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF67 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF67 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11B2 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_184)
{
    // BF68;BF68;1108 116A 11B3;BF68;1108 116A 11B3; 
    // (뽨; 뽨; 뽨; 뽨; 뽨; ) HANGUL SYLLABLE BBWALS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF68 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF68 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF68 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11B3 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_185)
{
    // BF69;BF69;1108 116A 11B4;BF69;1108 116A 11B4; 
    // (뽩; 뽩; 뽩; 뽩; 뽩; ) HANGUL SYLLABLE BBWALT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF69 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF69 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF69 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11B4 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_186)
{
    // BF6A;BF6A;1108 116A 11B5;BF6A;1108 116A 11B5; 
    // (뽪; 뽪; 뽪; 뽪; 뽪; ) HANGUL SYLLABLE BBWALP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF6A }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF6A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF6A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11B5 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_187)
{
    // BF6B;BF6B;1108 116A 11B6;BF6B;1108 116A 11B6; 
    // (뽫; 뽫; 뽫; 뽫; 뽫; ) HANGUL SYLLABLE BBWALH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF6B }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF6B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF6B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11B6 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_188)
{
    // BF6C;BF6C;1108 116A 11B7;BF6C;1108 116A 11B7; 
    // (뽬; 뽬; 뽬; 뽬; 뽬; ) HANGUL SYLLABLE BBWAM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF6C }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF6C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF6C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11B7 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_189)
{
    // BF6D;BF6D;1108 116A 11B8;BF6D;1108 116A 11B8; 
    // (뽭; 뽭; 뽭; 뽭; 뽭; ) HANGUL SYLLABLE BBWAB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF6D }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF6D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF6D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11B8 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_190)
{
    // BF6E;BF6E;1108 116A 11B9;BF6E;1108 116A 11B9; 
    // (뽮; 뽮; 뽮; 뽮; 뽮; ) HANGUL SYLLABLE BBWABS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF6E }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF6E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF6E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11B9 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_191)
{
    // BF6F;BF6F;1108 116A 11BA;BF6F;1108 116A 11BA; 
    // (뽯; 뽯; 뽯; 뽯; 뽯; ) HANGUL SYLLABLE BBWAS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF6F }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF6F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF6F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11BA }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_192)
{
    // BF70;BF70;1108 116A 11BB;BF70;1108 116A 11BB; 
    // (뽰; 뽰; 뽰; 뽰; 뽰; ) HANGUL SYLLABLE BBWASS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF70 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF70 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF70 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11BB }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_193)
{
    // BF71;BF71;1108 116A 11BC;BF71;1108 116A 11BC; 
    // (뽱; 뽱; 뽱; 뽱; 뽱; ) HANGUL SYLLABLE BBWANG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF71 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF71 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF71 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11BC }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_194)
{
    // BF72;BF72;1108 116A 11BD;BF72;1108 116A 11BD; 
    // (뽲; 뽲; 뽲; 뽲; 뽲; ) HANGUL SYLLABLE BBWAJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF72 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF72 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF72 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11BD }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_195)
{
    // BF73;BF73;1108 116A 11BE;BF73;1108 116A 11BE; 
    // (뽳; 뽳; 뽳; 뽳; 뽳; ) HANGUL SYLLABLE BBWAC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF73 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF73 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF73 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11BE }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_196)
{
    // BF74;BF74;1108 116A 11BF;BF74;1108 116A 11BF; 
    // (뽴; 뽴; 뽴; 뽴; 뽴; ) HANGUL SYLLABLE BBWAK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF74 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF74 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF74 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11BF }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_197)
{
    // BF75;BF75;1108 116A 11C0;BF75;1108 116A 11C0; 
    // (뽵; 뽵; 뽵; 뽵; 뽵; ) HANGUL SYLLABLE BBWAT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF75 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF75 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF75 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11C0 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_198)
{
    // BF76;BF76;1108 116A 11C1;BF76;1108 116A 11C1; 
    // (뽶; 뽶; 뽶; 뽶; 뽶; ) HANGUL SYLLABLE BBWAP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF76 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF76 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF76 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11C1 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_036_199)
{
    // BF77;BF77;1108 116A 11C2;BF77;1108 116A 11C2; 
    // (뽷; 뽷; 뽷; 뽷; 뽷; ) HANGUL SYLLABLE BBWAH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xBF77 }};
        std::array<uint32_t, 1> const c2 = {{ 0xBF77 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1108, 0x116A, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xBF77 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1108, 0x116A, 0x11C2 }};

        {
            boost::text::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            boost::text::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize_to_nfd(str);
            boost::text::utf32_range utf32_range(str);
            EXPECT_EQ(std::distance(utf32_range.begin(), utf32_range.end()), c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : utf32_range) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


