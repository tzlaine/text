<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>The Text Layer</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Text (Proposed)">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Text (Proposed)">
<link rel="prev" href="a_bit_about_ropes.html" title="A Bit About Ropes">
<link rel="next" href="performance_considerations.html" title="Performance Considerations">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="a_bit_about_ropes.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="performance_considerations.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_text__proposed_.the_text_layer"></a><a class="link" href="the_text_layer.html" title="The Text Layer">The Text Layer</a>
</h2></div></div></div>
<p>
      The text layer of Boost.Text consists mostly of four types: <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>, <code class="computeroutput"><a class="link" href="../boost/text/text_view.html" title="Type definition text_view">text_view</a></code>, <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">rope</a></code>, and <code class="computeroutput"><a class="link" href="../boost/text/rope_view.html" title="Type definition rope_view">rope_view</a></code>. These are directly
      analogous to <code class="computeroutput">std::string</code>,
      <code class="computeroutput">std::string_view</code>,
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>,
      and <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope_view.html" title="Type definition unencoded_rope_view">unencoded_rope_view</a></code>,
      respectively. In fact, each of the text layer types has a single data member
      &#8212; an object of the corresponding unencoded type.
    </p>
<p>
      Each of these four types is a typedef of a general-purpose template. For instance,
      <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>
      is a specialization of <code class="computeroutput"><a class="link" href="../boost/text/basic_text.html" title="Struct template basic_text">basic_text</a></code> that is normalized
      NFC, with a code unit type of <code class="computeroutput"><span class="keyword">char</span></code>,
      and using <code class="computeroutput">std::string</code>
      as the underlying storage.
    </p>
<p>
      The <code class="computeroutput"><span class="identifier">basic_</span></code> templates are:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          <code class="computeroutput"><a class="link" href="../boost/text/basic_text.html" title="Struct template basic_text">basic_text</a></code>
        </li>
<li class="listitem">
          <code class="computeroutput"><a class="link" href="../boost/text/basic_text_view.html" title="Struct template basic_text_view">basic_text_view</a></code>
        </li>
<li class="listitem">
          <code class="computeroutput"><a class="link" href="../boost/text/basic_rope.html" title="Struct template basic_rope">basic_rope</a></code>
        </li>
<li class="listitem">
          <code class="computeroutput"><a class="link" href="../boost/text/basic_rope_view.html" title="Struct template basic_rope_view">basic_rope_view</a></code>
        </li>
</ul></div>
<p>
      Each template can be configured: to maintain one of the five supported normalization
      forms; with a particular underlying code unit type; and, for those that have
      underlying storage (<code class="computeroutput"><a class="link" href="../boost/text/basic_text.html" title="Struct template basic_text">basic_text</a></code> and <code class="computeroutput"><a class="link" href="../boost/text/basic_rope.html" title="Struct template basic_rope">basic_rope</a></code>), with the type of
      storage container to use. The UTF format each template uses is deduced from
      the code point type. For instance, <code class="computeroutput"><span class="keyword">char</span></code>
      and <code class="computeroutput"><span class="identifier">char8_t</span></code> imply UTF-8, whereas
      <code class="computeroutput"><span class="identifier">uint16_t</span></code> and <code class="computeroutput"><span class="keyword">char16_t</span></code> imply UTF-16. These templates do not
      support UTF-32.
    </p>
<p>
      For the rest of the documentation, we will focus on the four specializations
      of these templates that Boost.Text provides: <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>, <code class="computeroutput"><a class="link" href="../boost/text/text_view.html" title="Type definition text_view">text_view</a></code>, <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">rope</a></code>, and <code class="computeroutput"><a class="link" href="../boost/text/rope_view.html" title="Type definition rope_view">rope_view</a></code>.
    </p>
<p>
      Let's consider one of these specializations in particular, <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>. Its underlying storage
      is a <code class="computeroutput">std::string</code>,
      as mentioned before. The <code class="computeroutput"><span class="keyword">char</span></code>s
      in the <code class="computeroutput">std::string</code>
      are UTF-8 encoded. The code point view of those UTF-8 encoded <code class="computeroutput"><span class="keyword">char</span></code>s is available by using <code class="computeroutput"><a class="link" href="../boost/text/utf_8_to_32_iterator.html" title="Struct template utf_8_to_32_iterator">utf_8_to_32_iterator</a></code>. Since
      <code class="computeroutput"><a class="link" href="../boost/text/utf_8_to_32_iterator.html" title="Struct template utf_8_to_32_iterator">utf_8_to_32_iterator</a></code>
      generates replacement characters when it encounters a broken encoding, no runtime
      checks ever need to be performed on the encoding of the <code class="computeroutput"><span class="keyword">char</span></code>s
      in a <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>'s
      <code class="computeroutput">std::string</code>
      data member.
    </p>
<p>
      All the text layer types are kept normalized at all times; the views may be
      initialized only from known-normalized types. There is a runtime cost associated
      with normalizing text that is inserted into a text layer type.
    </p>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>
      and <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">rope</a></code>
      are also kept in <a href="https://unicode.org/reports/tr15/#Stream_Safe_Text_Format" target="_top">Stream-Safe
      Format</a>; <code class="computeroutput"><a class="link" href="../boost/text/text_view.html" title="Type definition text_view">text_view</a></code>
      and <code class="computeroutput"><a class="link" href="../boost/text/rope_view.html" title="Type definition rope_view">rope_view</a></code>
      may be initialized only from known-stream-safe types.
    </p>
<p>
      The text layer types are centered around graphemes instead of <code class="computeroutput"><span class="keyword">char</span></code>s. Since graphemes are variable-length,
      this means that all indexing is done using iterators instead of integral indices;
      there is no random access to the graphemes in the text layer types.
    </p>
<h4>
<a name="boost_text__proposed_.the_text_layer.h0"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_text_layer.graphemes"></a></span><a class="link" href="the_text_layer.html#boost_text__proposed_.the_text_layer.graphemes">Graphemes</a>
    </h4>
<p>
      When you dereference an iterator that you get from one of the text layer types,
      you get a <code class="computeroutput"><a class="link" href="../boost/text/grapheme_ref.html" title="Struct template grapheme_ref">grapheme_ref</a></code>.
      This is a non-owning range of code points.
    </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span> <span class="identifier">t</span> <span class="special">=</span> <span class="string">"A bit of text."</span><span class="special">;</span>

<span class="comment">// grapheme_refs should be declared as values in range-based for loops, since</span>
<span class="comment">// they are small value types.</span>
<span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">grapheme</span> <span class="special">:</span> <span class="identifier">t</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">grapheme</span><span class="special">;</span> <span class="comment">// grapheme_ref is directly streamable.</span>
    <span class="comment">// grapheme_ref is also a code point range, of course</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">cp</span> <span class="special">:</span> <span class="identifier">grapheme</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">// Do something with code point cp here....</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
</pre>
<p>
    </p>
<p>
      If you want an owning set of code points, you can construct a <code class="computeroutput"><a class="link" href="../boost/text/grapheme.html" title="Struct grapheme">grapheme</a></code> (either from a <code class="computeroutput"><a class="link" href="../boost/text/grapheme_ref.html" title="Struct template grapheme_ref">grapheme_ref</a></code>,
      or by some other means).
    </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// These functions don't do anything interesting; Just pay attention to the</span>
<span class="comment">// interfaces.</span>

<span class="comment">// This returns a view into a temporary.  Don't do this.</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">grapheme_ref</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">iterator</span><span class="special">::</span><span class="identifier">iterator_type</span><span class="special">&gt;</span>
<span class="identifier">find_first_dot_bad</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span> <span class="identifier">t</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">grapheme</span> <span class="special">:</span> <span class="identifier">t</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">uint32_t</span> <span class="identifier">target</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span><span class="char">'.'</span><span class="special">};</span>
        <span class="comment">// Using the one from Boost.Algorithm, so we get the 4-param version</span>
        <span class="comment">// even if we're not using a C++14 compiler.</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">algorithm</span><span class="special">::</span><span class="identifier">equal</span><span class="special">(</span>
                <span class="identifier">grapheme</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">grapheme</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">target</span><span class="special">,</span> <span class="identifier">target</span> <span class="special">+</span> <span class="number">1</span><span class="special">))</span> <span class="special">{</span>
            <span class="comment">// This line compiles without warnings.  The compiler doesn't know</span>
            <span class="comment">// how to tell me I'm returning a dangling reference, because it's</span>
            <span class="comment">// a view, not a builtin reference.</span>
            <span class="keyword">return</span> <span class="identifier">grapheme</span><span class="special">;</span>
        <span class="special">}</span>
    <span class="special">}</span>
    <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">grapheme_ref</span><span class="special">&lt;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">iterator</span><span class="special">::</span><span class="identifier">iterator_type</span><span class="special">&gt;();</span>
<span class="special">}</span>

<span class="comment">// This returns a grapheme that owns its code point storage, so it cannot</span>
<span class="comment">// dangle.  Do this.</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">grapheme</span> <span class="identifier">find_first_dot_good</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span> <span class="identifier">t</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">grapheme</span> <span class="special">:</span> <span class="identifier">t</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">uint32_t</span> <span class="identifier">target</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="special">{</span><span class="char">'.'</span><span class="special">};</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">algorithm</span><span class="special">::</span><span class="identifier">equal</span><span class="special">(</span>
                <span class="identifier">grapheme</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">grapheme</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">target</span><span class="special">,</span> <span class="identifier">target</span> <span class="special">+</span> <span class="number">1</span><span class="special">))</span> <span class="special">{</span>
            <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">grapheme</span><span class="special">(</span><span class="identifier">grapheme</span><span class="special">);</span>
        <span class="special">}</span>
    <span class="special">}</span>
    <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">grapheme</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
    </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        <code class="computeroutput"><a class="link" href="../boost/text/grapheme.html" title="Struct grapheme">grapheme</a></code>
        has a small-buffer optimization so that using it seldom involves allocations.
        This also implies that an array of <code class="computeroutput"><a class="link" href="../boost/text/grapheme.html" title="Struct grapheme">graphemes</a></code> is likely to be wasteful
        of storage. If you want a bunch of graphemes, you should probably be using
        a <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>.
      </p></td></tr>
</table></div>
<p>
      An individual grapheme, in the form of a <code class="computeroutput"><a class="link" href="../boost/text/grapheme.html" title="Struct grapheme">grapheme</a></code> or <code class="computeroutput"><a class="link" href="../boost/text/grapheme_ref.html" title="Struct template grapheme_ref">grapheme_ref</a></code>, can be inserted
      into a <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>
      or <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">rope</a></code>.
    </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        The grapheme is the unit of work within the text layer. When using text layer
        types, you should always use the <a class="link" href="concepts.html#boost_text__proposed_.concepts.graphemerange">GraphemeRange</a>
        overloads of the Unicode algorithms.
      </p></td></tr>
</table></div>
<h4>
<a name="boost_text__proposed_.the_text_layer.h1"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_text_layer.grapheme_iterators"></a></span><a class="link" href="the_text_layer.html#boost_text__proposed_.the_text_layer.grapheme_iterators">Grapheme
      Iterators</a>
    </h4>
<p>
      Since the grapheme is the unit of work within the text layer, it's natural
      that the text layer types return <code class="computeroutput"><a class="link" href="../boost/text/grapheme_iterator.html" title="Struct template grapheme_iterator">grapheme_iterators</a></code> from <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code> and
      <code class="computeroutput"><span class="identifier">end</span><span class="special">()</span></code>.
      But what about the times when you actually want to deal with sequences of code
      points or <code class="computeroutput"><span class="keyword">char</span></code>s? This comes up
      often when you need to use legacy interfaces.
    </p>
<p>
      Fortunately, that's really easy. <code class="computeroutput"><a class="link" href="../boost/text/grapheme_iterator.html" title="Struct template grapheme_iterator">grapheme_iterator</a></code> has a <code class="computeroutput"><span class="identifier">base</span><span class="special">()</span></code> member
      that returns its underlying code point iterator. The code point iterator used
      in the text layer types is always <code class="computeroutput"><a class="link" href="../boost/text/utf_8_to_32_iterator.html" title="Struct template utf_8_to_32_iterator">utf_8_to_32_iterator</a></code>, which also
      has a <code class="computeroutput"><span class="identifier">base</span><span class="special">()</span></code>
      member that returns <span class="emphasis"><em>it's</em></span> underlying <code class="computeroutput"><span class="keyword">char</span></code>
      iterator:
    </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// t is a GraphemeRange.</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span> <span class="identifier">t</span> <span class="special">=</span> <span class="string">"This is a short sentence."</span><span class="special">;</span>

<span class="comment">// This is a code point range that contains all the same code points as t.</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf32_view</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">utf_8_to_32_iterator</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*&gt;&gt;</span> <span class="identifier">cps</span><span class="special">(</span>
    <span class="identifier">t</span><span class="special">.</span><span class="identifier">begin</span><span class="special">().</span><span class="identifier">base</span><span class="special">(),</span> <span class="identifier">t</span><span class="special">.</span><span class="identifier">end</span><span class="special">().</span><span class="identifier">base</span><span class="special">());</span>

<span class="comment">// This is achar range that contains all the same code units as t, though it</span>
<span class="comment">// is not null-terminated like t's underlying storage is.</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="identifier">chars</span><span class="special">(</span><span class="identifier">t</span><span class="special">.</span><span class="identifier">begin</span><span class="special">().</span><span class="identifier">base</span><span class="special">().</span><span class="identifier">base</span><span class="special">(),</span> <span class="identifier">t</span><span class="special">.</span><span class="identifier">end</span><span class="special">().</span><span class="identifier">base</span><span class="special">().</span><span class="identifier">base</span><span class="special">());</span>
</pre>
<p>
    </p>
<p>
      Since <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>'s
      iterators are all declared in terms of <code class="computeroutput"><span class="keyword">char</span>
      <span class="special">*</span></code> or <code class="computeroutput"><span class="keyword">char</span>
      <span class="keyword">const</span> <span class="special">*</span></code>,
      you have convenient access to the underlying null-terminated sequence of characters:
    </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span> <span class="identifier">t</span> <span class="special">=</span> <span class="string">"This is a short sentence."</span><span class="special">;</span>

<span class="identifier">assert</span><span class="special">(</span><span class="identifier">strlen</span><span class="special">(</span><span class="identifier">t</span><span class="special">.</span><span class="identifier">begin</span><span class="special">().</span><span class="identifier">base</span><span class="special">().</span><span class="identifier">base</span><span class="special">())</span> <span class="special">==</span> <span class="number">25</span><span class="special">);</span>

<span class="identifier">t</span> <span class="special">=</span> <span class="string">"This is a short s&#233;ance."</span><span class="special">;</span> <span class="comment">// &#233; occupies two UTF-8 code units.</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">strlen</span><span class="special">(</span><span class="identifier">t</span><span class="special">.</span><span class="identifier">begin</span><span class="special">().</span><span class="identifier">base</span><span class="special">().</span><span class="identifier">base</span><span class="special">())</span> <span class="special">==</span> <span class="number">24</span><span class="special">);</span>
</pre>
<p>
    </p>
<h4>
<a name="boost_text__proposed_.the_text_layer.h2"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_text_layer.a_shortcoming"></a></span><a class="link" href="the_text_layer.html#boost_text__proposed_.the_text_layer.a_shortcoming">A
      Shortcoming</a>
    </h4>
<p>
      There is a problem with basing all your Unicode operations on graphemes. Graphemes
      do not always line up with the text segmentation algorithms. Specifically,
      lines are not guaranteed to end exactly on a grapheme break (the other text
      breaking algorithms all happen to end on grapheme breaks).
    </p>
<p>
      There are two things to note here:
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          The cases where a line does not end on a grapheme break are obscure corner
          cases that do not often come up in practice.
        </li>
<li class="listitem">
          Graphemes are context-sensitive. In other words, if you break a line in
          the middle of a grapheme <code class="computeroutput"><span class="identifier">G</span></code>,
          <code class="computeroutput"><span class="identifier">G</span></code>'s code points before
          the line break from their own grapheme, and the rest of <code class="computeroutput"><span class="identifier">G</span></code>'s
          code points form another grapheme. In other words, breaking graphemes is
          pretty benign; it's not like breaking encoding or normalization.
        </li>
</ol></div>
<h4>
<a name="boost_text__proposed_.the_text_layer.h3"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_text_layer.the_text_layer_types"></a></span><a class="link" href="the_text_layer.html#boost_text__proposed_.the_text_layer.the_text_layer_types">The Text
      Layer Types</a>
    </h4>
<p>
      As mentioned before, this layer has four types (<code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>, <code class="computeroutput"><a class="link" href="../boost/text/text_view.html" title="Type definition text_view">text_view</a></code>, <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">rope</a></code>, and <code class="computeroutput"><a class="link" href="../boost/text/rope_view.html" title="Type definition rope_view">rope_view</a></code>) that are directly
      analogous to the four major unencoded types that they use for storage (<code class="computeroutput">std::string</code>, <code class="computeroutput">std::string_view</code>,
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>,
      and <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope_view.html" title="Type definition unencoded_rope_view">unencoded_rope_view</a></code>).
      The high-level semantics of these underlying types is the same:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          <code class="computeroutput">std::string</code>
          and <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>
          are owning and contiguous.
        </li>
<li class="listitem">
          <code class="computeroutput">std::string_view</code>
          and <code class="computeroutput"><a class="link" href="../boost/text/text_view.html" title="Type definition text_view">text_view</a></code>
          and non-owning and contiguous.
        </li>
<li class="listitem">
          <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Type definition unencoded_rope">unencoded_rope</a></code>
          and <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">rope</a></code>
          are owning and discontiguous.
        </li>
<li class="listitem">
          <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope_view.html" title="Type definition unencoded_rope_view">unencoded_rope_view</a></code>
          and <code class="computeroutput"><a class="link" href="../boost/text/rope_view.html" title="Type definition rope_view">rope_view</a></code>
          are non-owning and discontiguous.
        </li>
</ul></div>
<p>
      Many other high-level semantics apply as well, such as the size-type used for
      each. How about the differences?
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          The text layer types are sequences of graphemes, not <code class="computeroutput"><span class="keyword">char</span></code>s.
        </li>
<li class="listitem">
          The text layer types are bidirectional ranges, not random-access ranges
          like the unencoded types.
        </li>
<li class="listitem">
          There are no relational operators (<code class="computeroutput"><span class="special">&lt;</span></code>,
          <code class="computeroutput"><span class="special">&lt;=</span></code>, <code class="computeroutput"><span class="special">&gt;</span></code>,
          and <code class="computeroutput"><span class="special">&gt;=</span></code>). This is because
          this would lead to implicit ordering based on the type's binary representation,
          and not on some collation. This is wrong in some &#8212; but not all &#8212;
          contexts, making it bad candidate for implicit semantics.
        </li>
<li class="listitem">
          There are still equality comparison operators though (<code class="computeroutput"><span class="special">==</span></code>
          and <code class="computeroutput"><span class="special">!=</span></code>), because they are
          fundamental.
        </li>
<li class="listitem">
          There are no comparisons of any kind between the text layer types and the
          unencoded types. This is because the former are all UTF-8 encoded and normalized,
          and the latter are not. Such comparisons across type should require explicit
          indication of the desired semantics.
        </li>
<li class="listitem">
          There are no <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>
          members. To implement this would be an <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="identifier">N</span><span class="special">)</span></code>
          operation, and so <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code> would be a very misleading name for this.
          There is instead a <code class="computeroutput"><span class="identifier">distance</span><span class="special">()</span></code> function that returns the number of graphemes
          in <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="identifier">N</span><span class="special">)</span></code> time.
          There is an <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="number">1</span><span class="special">)</span></code> member
          <code class="computeroutput"><span class="identifier">storage_code_points</span><span class="special">()</span></code>
          that returns the size (in <code class="computeroutput"><span class="keyword">char</span></code>s)
          of the underlying storage.
        </li>
<li class="listitem">
          Since it would imply a maximum number of graphemes, there is no <code class="computeroutput"><span class="identifier">max_size</span><span class="special">()</span></code>
          either. There is instead a <code class="computeroutput"><span class="identifier">max_code_points</span><span class="special">()</span></code>.
        </li>
<li class="listitem">
          <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>
          has a <code class="computeroutput"><span class="identifier">capacity_code_points</span><span class="special">()</span></code> instead of a <code class="computeroutput"><span class="identifier">capacity</span><span class="special">()</span></code> member.
        </li>
<li class="listitem">
          There are two members that allow you to steal and/or replace the underlying
          storage of the owning text layer types (<code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code> and <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">rope</a></code>). <code class="computeroutput"><span class="identifier">extract</span><span class="special">()</span></code> moves the underlying container out, and
          an overload of <code class="computeroutput"><span class="identifier">replace</span><span class="special">()</span></code> moves it in. <code class="computeroutput"><span class="identifier">replace</span><span class="special">()</span></code> requires that the moved-in container
          is normalized and in <a href="https://unicode.org/reports/tr15/#Stream_Safe_Text_Format" target="_top">Stream-Safe
          Format</a>.
        </li>
</ul></div>
<h4>
<a name="boost_text__proposed_.the_text_layer.h4"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_text_layer.an_odd_thing_about_erase_insert_replace"></a></span><a class="link" href="the_text_layer.html#boost_text__proposed_.the_text_layer.an_odd_thing_about_erase_insert_replace">An
      Odd Thing About Erase/Insert/Replace</a>
    </h4>
<p>
      When you insert into a <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>
      or <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">rope</a></code>,
      you get back an view that points to the inserted text. This is not what the
      standard C++ containers do.
    </p>
<p>
      Image that <code class="computeroutput"><span class="identifier">insert</span><span class="special">()</span></code>
      returned a single iterator, as the standard containers do. So, I would get
      an iterator that points to the start of the insertion:
    </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">rope</span> <span class="identifier">r</span><span class="special">(</span><span class="string">"e"</span><span class="special">);</span>
<span class="keyword">auto</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">r</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">r</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="char">'f'</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">r</span><span class="special">.</span><span class="identifier">distance</span><span class="special">()</span> <span class="special">==</span> <span class="number">2</span><span class="special">);</span>           <span class="comment">// We added a grapheme.</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">it</span> <span class="special">==</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">next</span><span class="special">(</span><span class="identifier">r</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()));</span>  <span class="comment">// This one, in fact.</span>
</pre>
<p>
      Not so fast. If I insert a sequence starting with one or more combining code
      points, the beginning of the insertion might get combined with the preceding
      code point (due to normalization) or grapheme (because combining marks at the
      end of a grapheme are just part of that grapheme). Just as importantly, the
      same thing can happen at the end of the insertion, too.
    </p>
<p>
      For these reasons, <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>
      returns a view that indicates the full extent of its graphemes that were changed
      by erase/insert/replace.
    </p>
<pre class="programlisting"><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*</span> <span class="identifier">combining_diaeresis</span> <span class="special">=</span> <span class="identifier">u8</span><span class="string">"\u0308"</span><span class="special">;</span>
<span class="identifier">text</span><span class="special">::</span><span class="identifier">text</span> <span class="identifier">t</span><span class="special">(</span><span class="string">"e"</span><span class="special">);</span>

<span class="keyword">auto</span> <span class="identifier">v</span> <span class="special">=</span> <span class="identifier">t</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">t</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">combining_diaeresis</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">t</span><span class="special">.</span><span class="identifier">distance</span><span class="special">()</span> <span class="special">==</span> <span class="number">1</span><span class="special">);</span>    <span class="comment">// No new grapheme!  We now have the single code point '&#235;'.</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">v</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">t</span><span class="special">.</span><span class="identifier">begin</span><span class="special">());</span>

<span class="identifier">it</span> <span class="special">=</span> <span class="identifier">t</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">t</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">combining_diaeresis</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">t</span><span class="special">.</span><span class="identifier">distance</span><span class="special">()</span> <span class="special">==</span> <span class="number">1</span><span class="special">);</span>    <span class="comment">// Still no new grapheme.  We now have a grapheme with the code points '&#235;' and '&#168;'.</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">v</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">t</span><span class="special">.</span><span class="identifier">begin</span><span class="special">());</span>
</pre>
<p>
      This behavior is correct, but a bit surprising when you first see it.
    </p>
<p>
      Since you may want to use <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code> with some standard facilities
      that expect erase/insert/replace to return a single iterator, the view returned
      is implicitly convertible to a single iterator; the view's <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code> is used for this.
    </p>
<h4>
<a name="boost_text__proposed_.the_text_layer.h5"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_text_layer.picking_the_right_string_type"></a></span><a class="link" href="the_text_layer.html#boost_text__proposed_.the_text_layer.picking_the_right_string_type">Picking
      the Right String Type</a>
    </h4>
<div class="table">
<a name="boost_text__proposed_.the_text_layer.t0"></a><p class="title"><b>Table&#160;1.7.&#160;Picking the Right Text Type</b></p>
<div class="table-contents"><table class="table" summary="Picking the Right Text Type">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                If I want ...
              </p>
            </th>
<th>
              <p>
                ... my text type is:
              </p>
            </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                a reference to some text that will outlive the reference, without
                allocating
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/text_view.html" title="Type definition text_view">text_view</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                mutable text with efficient mutation at the end of the string
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                mutable text with efficient mutation at any point in the string
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">rope</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                text with contiguous storage
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/text_view.html" title="Type definition text_view">text_view</a></code>
                or <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                a null-terminated underlying string
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                mutable text the size of a single pointer
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">rope</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                thread-safe text
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">rope</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                text with the small-object optimization
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">text</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                text with copy-on-write semantics
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">rope</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                function parameters that may bind to <code class="computeroutput"><a class="link" href="../boost/text/text_view.html" title="Type definition text_view">text_views</a></code> or <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">texts</a></code>
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/text_view.html" title="Type definition text_view">text_view</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                function parameters that may bind to <code class="computeroutput"><a class="link" href="../boost/text/text_view.html" title="Type definition text_view">text_views</a></code>, <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Type definition text">texts</a></code>,
                <code class="computeroutput"><a class="link" href="../boost/text/rope.html" title="Type definition rope">ropes</a></code>,
                or <code class="computeroutput"><a class="link" href="../boost/text/rope_view.html" title="Type definition rope_view">rope_views</a></code>
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/rope_view.html" title="Type definition rope_view">rope_view</a></code>
              </p>
            </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2018 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="a_bit_about_ropes.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="performance_considerations.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
